[{"title":"LEETCODE PATTERNS","date":"2021-06-01T15:19:19.000Z","path":"posts/4273093055.html","text":"经历了面试才体会到不论头多硬都得好好刷leetcode。在reddit上学习到的先进科学文化知识，不错的网站和刷题表格。刷起来，朋友。 leetcode-patterns tips: 如果输入数组是有序的：二分查找、双指针； 如果要求互换、子集的：回溯； 如果给出树：DFS/BFS； 如果给出图：DFS/BFS； 如果给一个链表：双指针； 如果禁止递归：栈； 如果必须在原位置解决：交换符合条件的值、存储一个或多个不同值在相同指针； 如果求最大/小 子数组/子集/选项：动态规划； 如果求top/least K items：堆； 如果求公共字符串：Map、前缀树（trie） Map/Set 占用O(1)时间和O(n)空间； 排序 占用O(nlogn)时间和O(1)空间；","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://blog.feelyou.top/tags/leetcode/"}]},{"title":"The Elements of Statistical Learning","date":"2021-06-01T14:54:56.000Z","path":"posts/2650520387.html","text":"掌握、探索统计学习基础的问题是非常有必要的，算法领域变化如此之快，基础不牢固，很难跟上新的算法，加油。","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://blog.feelyou.top/tags/机器学习/"},{"name":"面试","slug":"面试","permalink":"http://blog.feelyou.top/tags/面试/"}]},{"title":"vue组件","date":"2021-05-28T00:18:01.000Z","path":"posts/3711662242.html","text":"概念 组件是视图层的基本组成单元。 组件是一个单独且可复用的功能模块的封装。 一个组件包括开始标签和结束标签，标签上可以写属性，并对属性赋值。内容则写在两个标签之内。 根节点为 ，这个 下只能且必须有一个根 组件。这是vue单文件组件规范。 一个组件的 data 选项必须是一个函数。 1234567891011121314&lt;template&gt; &lt;view&gt; &lt;view&gt;&#123;&#123;userName&#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; &quot;userName&quot;:&quot;foo&quot; &#125; &#125; &#125;&lt;/script&gt; 基础组件是内置在uni-app框架中的，包括view、text、input、button、video等几十个基础组件，列表详见：uni-app基础组件 插件市场组件导入把这个uni-rate组件导入到你的uni-app项目下，在需要的vue页面里引用它，就可以在指定的地方显示出这个五角星组件。123456&lt;!-- 在index.vue页面引用 uni-rate 组件--&gt;&lt;template&gt; &lt;view&gt; &lt;uni-rate&gt;&lt;/uni-rate&gt;&lt;!-- 这里会显示一个五角星，并且点击后会自动亮星 --&gt; &lt;/view&gt;&lt;/template&gt; 优势 可以将组件进行任意次数的复用。 合理的划分组件，有助于提高应用性能。 代码更加方便组织和管理，并且扩展性也更强，便于多人协同开发。 组件化开发能大幅度提高应用开发效率、测试性、复用性等。 注册在注册一个组件的时候，我们始终需要给它一个名字。 定义组件名的方式有两种： 使用 kebab-case当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 &lt;my-component-name&gt;。 使用 PascalCase当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。 也就是说 &lt;my-component-name&gt; 和 &lt;MyComponentName&gt; 都是可接受的。 在uni-app工程根目录下的 components 目录，创建并存放自定义组件：1234│─components 符合vue组件规范的uni-app组件目录│ └─componentA 符合‘components/组件名称/组件名称.vue’目录结构，easycom方式可直接使用组件│ └─componentA.vue 可复用的componentA组件│ └─component-a.vue 可复用的component-a组件 全局注册uni-app 支持配置全局组件，需在main.js 里进行全局注册，注册后就可在所有页面里使用该组件。 注意 Vue.component 的第一个参数必须是静态的字符串。 nvue 页面暂不支持全局组件。 main.js 里进行全局导入和注册 123import Vue from &apos;vue&apos;import pageHead from &apos;./components/page-head.vue&apos;Vue.component(&apos;page-head&apos;,pageHead) index.vue 里可直接使用组件 12345&lt;template&gt; &lt;view&gt; &lt;page-head&gt;&lt;/page-head&gt; &lt;/view&gt;&lt;/template&gt; 局部注册局部注册之前，在需要引用该组件的页面，导入你想使用的组件。 页面引入组件方式 如下通过两种方式导入一个角标的组件库，详见，推荐使用 easycom 方式引入。 传统vue规范： 在 index.vue 页面中，通过 import 方式引入组件 ，在 components 选项中定义你想要使用的组件。 123456789101112&lt;!-- 在index.vue引入 uni-badge 组件--&gt;&lt;template&gt; &lt;view&gt; &lt;uni-badge text=&quot;1&quot;&gt;&lt;/uni-badge&gt;&lt;!-- 3.使用组件 --&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; import uniBadge from &apos;@/components/uni-badge/uni-badge.vue&apos;;//1.导入组件（这步属于传统vue规范，但在uni-app的easycom下可以省略这步） export default &#123; components:&#123;uniBadge &#125;//2.注册组件（这步属于传统vue规范，但在uni-app的easycom下可以省略这步） &#125;&lt;/script&gt; 对于 components 对象中的每个 property 来说，其 property 名就是自定义元素的名字，其 property 值就是这个组件的选项对象。 在对象中放一个类似 uniBadge 的变量名其实是 uniBadge : uniBadge 的缩写，即这个变量名同时是： 用在模板中的自定义元素的名称 包含了这个组件选项的变量名(仅支持驼峰法命名) 2.通过uni-app的easycom： 将组件引入精简为一步。只要组件安装在项目的 components 目录下，并符合 components/组件名称/组件名称.vue 目录结构。就可以不用引用、注册，直接在页面中使用。123456789101112131415&lt;!-- 在index.vue引入 uni-badge 组件--&gt;&lt;template&gt; &lt;view&gt; &lt;uni-badge text=&quot;1&quot;&gt;&lt;/uni-badge&gt;&lt;!-- 3.使用组件 --&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; // 这里不用import引入，也不需要在components内注册uni-badge组件。template里就可以直接用 export default &#123; data() &#123; return &#123; &#125; &#125; &#125;&lt;/script&gt; easycom是自动开启的，不需要手动开启，有需求时可以在 pages.json 的 easycom 节点进行个性化设置，详见。 不管components目录下安装了多少组件，easycom打包后会自动剔除没有使用的组件，对组件库的使用尤为友好。 组件是 vue 技术中非常重要的部分，组件使得与ui相关的轮子可以方便的制造和共享，进而使得 vue 使用者的开发效率大幅提升。 uni-app 搭建了组件的插件市场，有很多现成的组件，若下载符合components/组件名称/组件名称.vue目录结构的组件，均可直接使用。uni-app插件市场 uni-app只支持 vue单文件组件（.vue 组件）。其他的诸如：动态组件，自定义 render ，和 &lt;script type=&quot;text/x-template&quot;&gt; 字符串模版等，在非H5端不支持。 propsprops 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。 选项 类型 说明 type String 、 Number 、 Boolean 、 Array 、 Object 、 Date 、 Function 、 Symbol ，任何自定义构造函数、或上述内容组成的数组 会检查一个 prop 是否是给定的类型，否则抛出警告 default any 为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。 required Boolean 定义该 prop 是否是必填项 validator Function 自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 false 的值 (也就是验证失败)，一个控制台警告将会被抛出 示例：123456789101112131415161718192021&lt;template&gt; &lt;view&gt; &lt;!-- 我是子组件componentA --&gt; &lt;view&gt;&#123;&#123;age&#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; // 检测类型 + 其他验证 age: &#123; type: Number, default: 0, required: true, validator: function(value) &#123; return value &gt;= 0 &#125; &#125; &#125; &#125;&lt;/script&gt; 123456&lt;template&gt; &lt;view&gt; &lt;!-- 我是父组件 --&gt; &lt;componentA :age=&quot;10&quot;&gt;&lt;/componentA&gt; &lt;/view&gt;&lt;/template&gt; 传递静态或动态 Prop 可以像这样给 prop 传入一个静态的值： 1&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt; 可以通过v-bind 动态赋值 1234567&lt;!-- 动态赋予一个变量的值 --&gt;&lt;blog-post v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;&lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;&lt;blog-post is-published&gt;&lt;/blog-post&gt;&lt;blog-post v-bind:is-published=&quot;post.isPublished&quot;&gt;&lt;/blog-post&gt; 传入一个对象的所有 property如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)。例如，对于一个给定的对象 post ： 1234post: &#123; id: 1, title: &apos;My Journey with Vue&apos;&#125; 123456&lt;blog-post v-bind=&quot;post&quot;&gt;&lt;/blog-post&gt;&lt;!-- 上面的模板等价于： --&gt;&lt;blog-post v-bind:id=&quot;post.id&quot; v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt; 单向数据流所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。 每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。1234567891011&lt;template&gt; &lt;view&gt; &lt;!-- 我是子组件componentA --&gt; &lt;view&gt;&#123;&#123;title&#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: [&apos;title&apos;] &#125;&lt;/script&gt; 123456789101112131415&lt;template&gt; &lt;view&gt; &lt;!-- 我是父组件 --&gt; &lt;componentA :title=&quot;title&quot;&gt;&lt;/componentA&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; title:&quot;hello&quot; &#125; &#125; &#125;&lt;/script&gt; 这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：1234567891011121314151617&lt;template&gt; &lt;view&gt; &lt;!-- 我是子组件componentA --&gt; &lt;view&gt;&#123;&#123;normalizedSize&#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: [&apos;size&apos;], computed: &#123; normalizedSize: function () &#123; return this.size.toLowerCase() &#125; &#125; &#125;&lt;/script&gt; 123456789101112131415&lt;template&gt; &lt;view&gt; &lt;!-- 我是父组件 --&gt; &lt;componentA :size=&quot;size&quot;&gt;&lt;/componentA&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; size:&quot;M&quot; &#125; &#125; &#125;&lt;/script&gt; ref被用来给元素或子组件注册引用信息，引用信息将会注册在父组件的 $refs 对象上。 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：12345//非H5端不支持通过this.$refs.content来获取view实例&lt;view ref=&quot;content&quot;&gt;hello&lt;/view&gt;//支持通过this.$refs.child来获取child-component实例&lt;child-component ref=&quot;child&quot;&gt;&lt;/child-component&gt; 当 ref 和 v-for 一起用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。 关于 ref 注册时间的重要说明： 因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们，它们还不存在！$refs 也不是响应式的，因此你不应该用它在模板中做数据绑定。 子组件ref尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。 访问子组件实例或子元素，通过 ref 为子组件赋予一个 ID 引用，在vue的js中可通过this.$refs.XXX来获取到组件对象。1&lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt; 你已经定义了这个 ref 的组件里，你可以使用：this.$refs.usernameInput来访问这个&lt;base-input&gt;实例。 示例：123456789101112131415161718192021//base-input子组件页面&lt;template&gt; &lt;view&gt; &lt;input :focus=&quot;isFocus&quot; type=&quot;text&quot; placeholder=&quot;请输入内容&quot; /&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&quot;base-input&quot;, data() &#123; return &#123; &quot;isFocus&quot;:false &#125;; &#125;, methods:&#123; focus()&#123; this.isFocus = true &#125; &#125; &#125;&lt;/script&gt; 允许父级组件通过下面的代码聚焦&lt;base-input&gt;里的输入框：1234567891011121314151617//index 父组件页面&lt;template&gt; &lt;view&gt; &lt;base-input ref=&quot;usernameInput&quot;&gt;&lt;/base-input&gt; &lt;button type=&quot;default&quot; @click=&quot;getFocus&quot;&gt;获取焦点&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods:&#123; getFocus()&#123; //通过组件定义的ref调用focus方法 this.$refs.usernameInput.focus() &#125; &#125; &#125;&lt;/script&gt; 注意 非H5端只能用于获取自定义组件，不能用于获取内置组件实例（如：view、text） 自定义事件将原生事件绑定到组件你可能有很多次想要在一个组件的根元素上直接监听一个原生事件。 这时，你可以使用 @事件的.native 修饰符： 注意：在app、小程序端和h5端表现不一致，h5端获取到的是浏览器原生事件。123456789101112131415&lt;template&gt; &lt;view&gt; &lt;!-- 我是父组件 --&gt; &lt;componentA @click.native=&quot;clickComponentA&quot; style=&quot;height: 200px;&quot;&gt;&lt;/componentA&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; clickComponentA()&#123; console.log(&quot;clickComponentA&quot;); &#125; &#125; &#125;&lt;/script&gt; 123456789101112131415&lt;template&gt; &lt;view&gt; &lt;!-- 我是子组件 --&gt; &lt;view type=&quot;default&quot; @click.stop=&quot;open&quot; style=&quot;height: 30px;&quot;&gt;点击&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods:&#123; open()&#123; console.log(&quot;open&quot;); &#125; &#125; &#125;&lt;/script&gt; .sync 修饰符当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定。 .sync 它会被扩展为一个自动更新父组件属性的 v-on 监听器。123456789101112131415&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;view&gt; &lt;syncA :title.sync=&quot;title&quot;&gt;&lt;/syncA&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; title:&quot;hello vue.js&quot; &#125; &#125; &#125;&lt;/script&gt; 123456789101112131415161718192021&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;view&gt; &lt;view @click=&quot;changeTitle&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; title: &#123; default: &quot;hello&quot; &#125;, &#125;, methods:&#123; changeTitle()&#123; //触发一个更新事件 this.$emit(&apos;update:title&apos;,&quot;uni-app&quot;) &#125; &#125; &#125;&lt;/script&gt; 插槽Vue 实现了一套内容分发的 API，将 slot 元素作为承载分发内容的出口。 它允许你像这样合成组件：1234567&lt;template&gt; &lt;view&gt; &lt;componentA&gt; Your Profile &lt;/componentA&gt; &lt;/view&gt;&lt;/template&gt; 在 &lt;componentA&gt; 的模板中可能会写为：1234567&lt;template&gt; &lt;view&gt; &lt;!-- 我是子组件componentA --&gt; &lt;view &gt;&#123;&#123;title&#125;&#125;&lt;/view&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/view&gt;&lt;/template&gt; 当组件渲染的时候，&lt;slot&gt;&lt;/slot&gt; 将会被替换为“Your Profile”。插槽内可以包含任何模板代码，包括 HTML ：12345678910&lt;template&gt; &lt;view&gt; &lt;!-- 我是父组件 --&gt; &lt;componentA&gt; &lt;view&gt;Your Profile&lt;/view&gt; &lt;!-- 添加一个 uni-icons 图标 --&gt; &lt;uni-icons type=&quot;contact&quot; size=&quot;30&quot;&gt;&lt;/uni-icons&gt; &lt;/componentA&gt; &lt;/view&gt;&lt;/template&gt; 如果 &lt;componentA&gt; 的 template 中没有包含一个&lt;slot&gt; 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃。 编译作用域当你想在一个插槽中使用数据时，例如：123&lt;navigation-link url=&quot;/profile&quot;&gt; Logged in as &#123;&#123; user.name &#125;&#125;&lt;/navigation-link&gt; 该插槽跟模板的其它地方一样可以访问相同的实例 property (也就是相同的“作用域”)，而不能访问 &lt;navigation-link&gt; 的作用域。例如 url 是访问不到的：12345678&lt;navigation-link url=&quot;/profile&quot;&gt; Clicking here will send you to: &#123;&#123; url &#125;&#125;&lt;!-- 这里的 `url` 会是 undefined， 因为其 (指该插槽的) 内容是_传递给_ &lt;navigation-link&gt; 的 而不是在 &lt;navigation-link&gt; 组件*内部*定义的。--&gt;&lt;/navigation-link&gt; 记住规则：父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 默认内容有时为一个插槽设置具体的后备 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染。例如在一个 &lt;submit-button&gt; 组件中：123&lt;button type=&quot;submit&quot;&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/button&gt; 我们可能希望这个&lt;button&gt;内绝大多数情况下都渲染文本“Submit”。为了将“Submit”作为后备内容，我们可以将它放在 &lt;slot&gt; 标签内：123&lt;button type=&quot;submit&quot;&gt; &lt;slot&gt;Submit&lt;/slot&gt;&lt;/button&gt; 当我在一个父级组件中使用 &lt;submit-button&gt; 并且不提供任何插槽内容时： 1234567&lt;!-- 父级组件：不提供任何插槽内容--&gt;&lt;submit-button&gt;&lt;/submit-button&gt;&lt;!-- 子组件：后备内容 “Submit” 将会被渲染： --&gt;&lt;button type=&quot;submit&quot;&gt; Submit&lt;/button&gt; 当我在一个父级组件中使用 &lt;submit-button&gt; 并且提供插槽内容时： 123456789&lt;!-- 父级组件：提供插槽内容--&gt;&lt;submit-button&gt; Save&lt;/submit-button&gt;&lt;!-- 子组件：则这个提供的内容将会被渲染从而取代后备内容： --&gt;&lt;button type=&quot;submit&quot;&gt; Save&lt;/button&gt; 具名插槽需要多个插槽时，可以利用 &lt;slot&gt; 元素的一个特殊的特性：name 来定义具名插槽 &lt;base-layout&gt; 子组件模板： 12345678910111213141516&lt;template&gt; &lt;view class=&quot;container&quot;&gt; &lt;header&gt; &lt;!-- 我们希望把页头放这里 --&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;!-- 我们希望把主要内容放这里 --&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;!-- 我们希望把页脚放这里 --&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/view&gt;&lt;/template&gt; 在向具名插槽提供内容的时候，我们可以在一个 &lt;template&gt; 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称： 1234567891011121314151617&lt;template&gt; &lt;view&gt; &lt;!-- 父组件使用子组件`&lt;base-layout&gt;`，节点上使用slot特性： --&gt; &lt;base-layout&gt; &lt;template v-slot:header&gt; &lt;view&gt;Here might be a page title&lt;/view&gt; &lt;/template&gt; &lt;template v-slot:default&gt; &lt;view&gt;A paragraph for the main content.&lt;/view&gt; &lt;view&gt;And another one.&lt;/view&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;view&gt;Here&apos;s some contact info&lt;/view&gt; &lt;/template&gt; &lt;/base-layout&gt; &lt;/view&gt;&lt;/template&gt; 现在 &lt;template&gt; 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 v-slot 的 &lt;template&gt; 中的内容都会被视为默认插槽的内容。 v-slot 只能添加在 上一个不带 name 的 出口会带有隐含的名字 “default” 。 具名插槽的缩写跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header ：1234567891011121314151617&lt;template&gt; &lt;view&gt; &lt;!-- 父组件使用子组件`&lt;base-layout&gt;`，节点上使用slot特性： --&gt; &lt;base-layout&gt; &lt;template #header&gt; &lt;view&gt;Here might be a page title&lt;/view&gt; &lt;/template&gt; &lt;view&gt;A paragraph for the main content.&lt;/view&gt; &lt;view&gt;And another one.&lt;/view&gt; &lt;template #footer&gt; &lt;view&gt;Here&apos;s some contact info&lt;/view&gt; &lt;/template&gt; &lt;/base-layout&gt; &lt;/view&gt;&lt;/template&gt; 作用域插槽在作用域插槽内，父组件可以拿到子组件的数据。子组件可以在 slot 标签上绑定属性值。 有时让插槽内容能够访问子组件中才有的数据是很有用的。123456&lt;!-- 子组件 &lt;current-user&gt;--&gt;&lt;template&gt; &lt;view&gt; &lt;slot&gt;&#123;&#123; user.lastName &#125;&#125;&lt;/slot&gt; &lt;/view&gt;&lt;/template&gt; 我们可能想换掉默认内容，用名而非姓来显示。如下：1234567&lt;template&gt; &lt;view&gt; &lt;current-user&gt; &#123;&#123; user.firstName &#125;&#125; &lt;/current-user&gt; &lt;/view&gt;&lt;/template&gt; 然而上述代码不会正常工作，因为只有&lt;current-user&gt;组件可以访问到 user 而我们提供的内容是在父级渲染的。 为了让 user 在父级的插槽内容中可用，我们可以将 user 作为 &lt;slot&gt; 元素的一个 attribute 绑定上去：123456789101112131415161718&lt;!-- 子组件 &lt;current-user&gt;--&gt;&lt;template&gt; &lt;view&gt; &lt;slot :user=&quot;user&quot;&gt;&#123;&#123;user.lastName&#125;&#125;&lt;/slot&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; user:&#123; &quot;lastName&quot;:&quot;bar&quot;, &quot;firstName&quot;:&quot;foo&quot; &#125; &#125; &#125; &#125;&lt;/script&gt; 绑定在 &lt;slot&gt; 元素上的 attribute 被称为插槽 prop。现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字：123456789&lt;template&gt; &lt;view&gt; &lt;current-user&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/template&gt; &lt;/current-user&gt; &lt;/view&gt;&lt;/template&gt; 在这个例子中，我们选择将包含所有插槽 prop 的对象命名为 slotProps ，但你也可以使用任意你喜欢的名字。 独占默认插槽的缩写语法就像假定未指明的内容对应默认插槽一样，不带参数的 v-slot 被假定对应默认插槽：123456789&lt;template&gt; &lt;view&gt; &lt;current-user&gt; &lt;template v-slot=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/template&gt; &lt;/current-user&gt; &lt;/view&gt;&lt;/template&gt; 默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确：1234567891011&lt;template&gt; &lt;view&gt; &lt;!-- 无效，会导致警告 --&gt; &lt;current-user v-slot=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;template v-slot:other=&quot;otherSlotProps&quot;&gt; slotProps is NOT available here &lt;/template&gt; &lt;/current-user&gt; &lt;/view&gt;&lt;/template&gt; 只要出现多个插槽，请始终为所有的插槽使用完整的基于 &lt;template&gt; 的语法：12345678910111213&lt;template&gt; &lt;view&gt; &lt;current-user&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/template&gt; &lt;template v-slot:other=&quot;otherSlotProps&quot;&gt; ... &lt;/template&gt; &lt;/current-user&gt; &lt;/view&gt;&lt;/template&gt; 解构插槽 Prop作用域插槽的内部工作原理是将你的插槽内容包裹在一个拥有单个参数的函数里：123function (slotProps) &#123; // 插槽内容&#125; 这意味着 v-slot 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。 所以在支持的环境下 ( 单文件组件 或 现代浏览器)，你也可以使用 ES2015 解构 来传入具体的插槽 prop，如下：123&lt;current-user v-slot=&quot;&#123; user &#125;&quot;&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt; 这样可以使模板更简洁，尤其是在该插槽提供了多个 prop 的时候。它同样开启了 prop 重命名等其它可能，例如将 user 重命名为 person ：123&lt;current-user v-slot=&quot;&#123; user: person &#125;&quot;&gt; &#123;&#123; person.firstName &#125;&#125;&lt;/current-user&gt; 你甚至可以定义后备内容，用于插槽 prop 是 undefined 的情形：123&lt;current-user v-slot=&quot;&#123; user = &#123; firstName: &apos;Guest&apos; &#125; &#125;&quot;&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt; 小程序不支持列表 作用域插槽（仅支持解构插槽、插槽内不支持复杂表达式且不可使用作用域外数据） 动态组件 异步组件 inline-template X-Templates keep-alive（App端也未支持） transition （可使用 animation 或 CSS 动画替代） 命名限制在 uni-app 中以下这些作为保留关键字，不可作为组件名。 a canvas cell content countdown datepicker div element embed header image img indicator input link list loading-indicator loading marquee meta refresh richtext script scrollable scroller select slider-neighbor slider slot span spinner style svg switch tabbar tabheader template text textarea timepicker transition-group transition video view web Tips 除以上列表中的名称外，标准的 HTML 及 SVG 标签名也不能作为组件名。 在百度小程序中使用时，不要在 data 内使用 hidden ，可能会导致渲染错误。 methods中不可使用与生命周期同名的方法名。 参考（不叫参考了，应该是摘抄）https://uniapp.dcloud.io/vue-components?id=%e4%bd%9c%e7%94%a8%e5%9f%9f%e6%8f%92%e6%a7%bd","tags":[]},{"title":"vuejs基础","date":"2021-05-27T14:33:33.000Z","path":"posts/2084610834.html","text":"vue 介绍在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。 Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统，只关注视图层，易于上手。所有东西都是响应式的。 vue的优势： 轻量级渐进式框架 视图、数据和结构的分离 响应式双向数据绑定 组件化 虚拟DOM 运行速度快，易于上手 便于与第三方库或既有项目整合 vue 基础比较文件类型以前：.html —&gt; html —&gt; htmlvue: .vue —&gt; vue —&gt; js 代码结构以前一个 html 大节点，里面有 script 和 style 节点；现在 template 是一级节点，用于写tag组件， script (js)和 style (css)是并列的一级节点，也就是有3个一级节点。这个叫vue单文件组件规范sfc。 template -&gt; view 外部文件引用方式以前通过script src、link href引入外部的js和css；现在是es6的写法， import 引入外部的js模块(注意不是文件)或css；1234 &lt;!-- 直接使用js模块的属性。在hello uni-app有示例 --&gt;var dateUtils = require(&apos;../../../common/util.js&apos;).dateUtils; &lt;!-- 将js导入并重命名为echarts，然后使用echarts.来继续执行方法。在hello uni-app有示例 --&gt;import * as echarts from &apos;/components/echarts/echarts.simple.min.js&apos;; css外部文件导入。全局样式，在根目录下的 app.vue 里写入，每个页面都会加载 app.vue 里的样式。123456 &lt;style&gt; @import &quot;./common/uni.css&quot;; .uni-hello-text&#123; color:#7A7E83; &#125; &lt;/style&gt; 另外，vue支持组件导入，可以更方便的封装一个包括界面、js、样式的库。 组件/标签的变化以前是html标签，比如 &lt;div&gt; ，现在是小程序组件，比如&lt;view&gt; 。 js的变化以前的 DOM 操作，如果你想改变某个 DOM 元素的显示内容，比如一个view的显示文字：给view设id，然后js里通过选择器获取 DOM 元素，进一步通过js进行赋值操作，修改 DOM 元素的属性或值。现在的做法，是vue的绑定模式，给这个 DOM 元素绑定一个js变量，在script中修改js变量的值，DOM 会自动变化，页面会自动更新渲染。前端改用 MVVM (Model-View-ViewModel的简写)模式，简单来说，Model:代表数据模型，View:只专注视图UI处理，ViewModel:只处理业务和数据。 模板语法插值数据绑定最常见的形式就是文本插值：1234567891011121314&lt;template&gt; &lt;view&gt; &lt;view&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; msg: &apos;Hello Vue!&apos; &#125; &#125; &#125;&lt;/script&gt; 里的内容将会被替代为对应数据对象上msg的值。无论何时，绑定的数据对象上msg发生了改变，插值处的内容都会更新。 使用js表达式js基本语句12345678910111213141516171819&lt;template&gt; &lt;view&gt; &lt;view&gt;&#123;&#123; number + 1 &#125;&#125;&lt;/view&gt; &lt;view&gt;&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;&lt;/view&gt; &lt;!-- 把一个字符串分割成字符串数组,颠倒其元素的顺序,把数组中的所有元素放入一个字符串 --&gt; &lt;view&gt;&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; number:1, ok:true, message: &apos;Hello Vue!&apos; &#125; &#125; &#125;&lt;/script&gt; 隔行换色1234567891011121314151617181920212223&lt;template&gt; &lt;view&gt; &lt;view v-for=&quot;(item,index) in 10&quot;&gt; &lt;!-- 通过%运算符求余数，实现隔行换色的效果 --&gt; &lt;view :class=&quot;&apos;list-&apos; + index%2&quot;&gt;&#123;&#123;index%2&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .list-0&#123; background-color: #aaaaff; &#125; .list-1&#123; background-color: #ffaa7f; &#125;&lt;/style&gt; 全局变量的一个白名单： Infinity undefined NaN isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent Math Number Date Array Object Boolean String RegExp Map Set JSON Intl 指令指令是带有 v- 前缀的特殊属性。 指令属性的值预期是单个 JavaScript 表达式 (v-for 是例外情况)。 指令的作用是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 一些指令能够接收一个“参数”，在指令名称之后以冒号（:）表示。 v-bind动态地绑定一个或多个属性，或一个组件 prop 到表达式。 v-bind缩写为‘ : ’ 在绑定 prop 时，prop 必须在子组件中声明。 可以用修饰符指定不同的绑定类型。12345678&lt;image v-bind:src=&quot;imgUrl&quot;&gt;&lt;/image&gt;&lt;!-- 缩写 --&gt;&lt;image :src=&quot;imgUrl&quot;&gt;&lt;/image&gt;&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt; v-onv-on 指令，它用于监听 DOM 事件。v-on缩写为‘ @ ’，下文简称为@事件1234&lt;!-- 完整语法 --&gt;&lt;view v-on:click=&quot;doSomething&quot;&gt;点击&lt;/view&gt; &lt;!-- 缩写 --&gt;&lt;view @click=&quot;doSomething&quot;&gt;点击&lt;/view&gt; v-once只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。h5、微信小程序均不支持123456&lt;view v-once&gt;This will never change: &#123;&#123;msg&#125;&#125;&lt;/view&gt; &lt;!-- 有子元素 --&gt; &lt;view v-once&gt; &lt;text&gt;comment&lt;/text&gt; &lt;text&gt;&#123;&#123;msg&#125;&#125;&lt;/text&gt; &lt;/view&gt; 并不一定能优化渲染性能，反而可能会拖慢客户端复用节点时的比对效率。那就少用 v-html更新元素的innerHTML 。注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。App端和H5端支持 v-html ，微信小程序会被转为 rich-text，其他端不支持 v-html 。跨端的富文本处理方案详见：https://ask.dcloud.net.cn/article/357721234567891011121314&lt;template&gt; &lt;view&gt; &lt;view v-html=&quot;rawHtml&quot;&gt;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; rawHtml: &apos;&lt;div style=&quot;text-align:center;background-color: #007AFF;&quot;&gt;&lt;div &gt;我是内容&lt;/div&gt;&lt;img src=&quot;https://bjetxgzv.cdn.bspapp.com/VKCEYUGU-uni-app-doc/d8590190-4f28-11eb-b680-7980c8a877b8.png&quot;/&gt;&lt;/div&gt;&apos; &#125; &#125; &#125;&lt;/script&gt; data 属性data 必须声明为返回一个初始数据对象的函数（注意函数内返回的数据对象不要直接引用函数外的对象）；否则页面关闭时，数据不会自动销毁，再次打开该页面时，会显示上次数据。谨记标准写法：123456789101112131415161718192021//正确用法，使用函数返回对象data() &#123; return &#123; title: &apos;Hello&apos; &#125;&#125;//错误写法，会导致再次打开页面时，显示上次数据data: &#123; title: &apos;Hello&apos;&#125;//错误写法，同样会导致多个组件实例对象数据相互影响const obj = &#123; title: &apos;Hello&apos;&#125;data() &#123; return &#123; obj &#125;&#125; Class 与 Style 绑定对象语法可以传给v-bind:class一个对象，实现动态地切换 class。也可以在对象中传入更多字段来动态切换多个 class。此外，v-bind:class 指令也可以与普通的 class 共存。1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;view&gt; &lt;!-- class --&gt; &lt;view class=&quot;static&quot; :class=&quot;&#123; active: isActive&#125;&quot;&gt;111&lt;/view&gt; &lt;view class=&quot;static&quot; :class=&quot;&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;&quot;&gt;222&lt;/view&gt; &lt;!-- style --&gt; &lt;view v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;333&lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; isActive: true, hasError: false, activeColor:&quot;green&quot;, fontSize:50 &#125; &#125; &#125; &lt;/script&gt; &lt;style&gt; .static&#123; color: #2C405A; &#125; .active&#123; background-color: #007AFF; &#125; .text-danger&#123; color: #DD524D; &#125; &lt;/style&gt; 渲染结果为1&lt;view class=&quot;static active&quot;&gt;&lt;/view&gt; 当 isActive 或者 hasError 变化时，class 列表将相应地更新。例如，如果 hasError 的值为 true ，class 列表将变为 static active text-danger。 数组语法可以把一个数组传给v-bind:class，以应用一个 class 列表。1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;view&gt; &lt;!-- class --&gt; &lt;view class=&quot;static&quot; :class=&quot;[activeClass,errorClass]&quot;&gt;111&lt;/view&gt; &lt;view class=&quot;static&quot; v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;222&lt;/view&gt;&lt;!-- 三元表达式 --&gt; &lt;view class=&quot;static&quot; v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;333&lt;/view&gt; &lt;!-- style --&gt; &lt;view v-bind:style=&quot;[&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;]&quot;&gt;444&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; isActive: true, activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;, activeColor:&quot;green&quot;, fontSize:50 &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .static&#123; font-size:30rpx; &#125; .active&#123; background-color: #007AFF; &#125; .text-danger&#123; font-size:60rpx; color:#DD524D; &#125;&lt;/style&gt; 注意：以:style=””这样的方式设置px像素值，其值为实际像素，不会被编译器转换。此外还可以用 computed 方法生成 class 或者 style 字符串，插入到页面中，举例说明：123456789101112131415161718192021222324&lt;template&gt; &lt;!-- 支持 --&gt; &lt;view class=&quot;container&quot; :class=&quot;computedClassStr&quot;&gt;&lt;/view&gt; &lt;view class=&quot;container&quot; :class=&quot;&#123;active: isActive&#125;&quot;&gt;&lt;/view&gt; &lt;!-- 不支持 --&gt; &lt;view class=&quot;container&quot; :class=&quot;computedClassObject&quot;&gt;&lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; isActive: true &#125; &#125;, computed: &#123; computedClassStr () &#123; return this.isActive ? &apos;active&apos; : &apos;&apos; &#125;, computedClassObject () &#123; return &#123; active: this.isActive &#125; &#125; &#125; &#125;&lt;/script&gt; 条件渲染v-if和v-elsev-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。 使用 v-else 指令来表示 v-if 的“else 块”。 在 JavaScript 中，truthy（真值）指的是在布尔值上下文中，转换后的值为真的值。所有值都是真值，除非它们被定义为 假值（即除 false、0、&quot;&quot;、null、undefined 和 NaN 以外皆为真值）。 123456789101112131415&lt;template&gt; &lt;view&gt; &lt;view v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/view&gt; &lt;view v-else&gt;你看不到我了&lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; seen: true &#125; &#125; &#125; &lt;/script&gt; v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用. 条件渲染分组因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 template 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 template 元素。1234&lt;template v-if=&quot;seen&quot;&gt; &lt;view&gt;标题&lt;/view&gt; &lt;view&gt;内容：现在你看到我了&lt;/view&gt;&lt;/template&gt; v-showv-show 是一个根据条件展示元素选项的指令。用法大致和 v-if 一样：1&lt;view v-show=&quot;ok&quot;&gt;Hello!&lt;/view&gt; 不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性的 display 。 注意，v-show 不支持 template 元素，也不支持 v-else。nvue 页面不支持 v-show。 v-if 和 v-show 区别v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做，直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多，不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换，来控制元素的显示和隐藏。 根据应用场景选择 v-if 有更高的切换开销，如果在运行时条件很少改变，则使用 v-if 较好。 v-show 有更高的初始渲染开销。如果需要非常频繁地切换，则使用 v-show 较好。 注意 不推荐同时使用 v-if 和 v-for。 当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。 列表渲染在 v-for 里使用数组v-for 指令可以实现基于一个数组来渲染一个列表。 v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。第一个参数 item 则是被迭代的数组元素的别名。第二个参数，即当前项的索引 index ，是可选的。12345678910111213141516171819&lt;template&gt; &lt;view&gt; &lt;view v-for=&quot;(item, index) in items&quot;&gt; &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; items: [ &#123; message: &apos;Foo&apos; &#125;, &#123; message: &apos;Bar&apos; &#125; ] &#125; &#125; &#125;&lt;/script&gt; 结果：120 - Foo1 - Bar 在 v-for 里使用对象你也可以用 v-for 来遍历一个对象的 property。 第一个参数 value 是被迭代的对象元素的属性值。第二个参数为 property 名称 (也就是键名)。第三个参数作为索引。 1234567891011121314151617181920&lt;template&gt; &lt;view&gt; &lt;view v-for=&quot;(value, name, index) in object&quot;&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; object: &#123; title: &apos;How to do lists in Vue&apos;, author: &apos;Jane Doe&apos;, publishedAt: &apos;2020-04-10&apos; &#125; &#125; &#125; &#125;&lt;/script&gt; 结果：1230.title: How to do lists in Vue,1.author: Jane Doe,2.publishedAt: 2020-04-10 列表渲染分组类似于 v-if，你也可以利用带有v-for的 template 来循环渲染一段包含多个元素的内容。比如：1234&lt;template v-for=&quot;item in items&quot;&gt; &lt;view&gt;&#123;&#123; item.message &#125;&#125;&lt;/view&gt; &lt;view class=&quot;divider&quot; role=&quot;presentation&quot;&gt;&lt;/view&gt;&lt;/template&gt; key当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。 如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 input 中的输入内容，switch 的选中状态），需要使用:key来指定列表中项目的唯一的标识符。 :key 的值以两种形式提供 使用 v-for 循环 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 使用 v-for 循环中 item 本身，这时需要 item 本身是一个唯一的字符串或者数字当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。 如不提供 :key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;view&gt; &lt;!-- array 中 item 的某个 property --&gt; &lt;view v-for=&quot;(item,index) in objectArray&quot; :key=&quot;item.id&quot;&gt; &#123;&#123;index +&apos;:&apos;+ item.name&#125;&#125; &lt;/view&gt; &lt;!-- item 本身是一个唯一的字符串或者数字时，可以使用 item 本身 --&gt; &lt;view v-for=&quot;(item,index) in stringArray&quot; :key=&quot;item&quot;&gt; &#123;&#123;index +&apos;:&apos;+ item&#125;&#125; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; objectArray:[&#123; id:0, name:&apos;li ming&apos; &#125;,&#123; id:1, name:&apos;wang peng&apos; &#125;], stringArray:[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;] &#125; &#125;&#125;&lt;/script&gt; 注意事项 在H5平台 使用 v-for 循环整数时和其他平台存在差异，如 v-for=”(item, index) in 10” 中，在H5平台 item 从 1 开始，其他平台 item 从 0 开始，可使用第二个参数 index 来保持一致。 在非H5平台 循环对象时不支持第三个参数，如 v-for=”(value, name, index) in object” 中，index 参数是不支持的。 小程序端数据为差量更新方式，由于小程序不支持删除对象属性，使用的设置值为 null 的方式替代，导致遍历时可能出现不符合预期的情况，需要自行过滤一下值为 null 的数据（相关反馈）。 在组件上使用 v-for在自定义组件上，你可以像在任何普通元素上一样使用 v-for 。1&lt;my-component v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&lt;/my-component&gt; 当在组件上使用 v-for 时，key是必须的。 事件处理器监听事件可以用@事件监听 DOM 事件，并在触发时运行一些 JavaScript 代码。123456789101112131415&lt;template&gt; &lt;view&gt; &lt;button @click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt; &lt;text&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;/text&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; counter:0 &#125; &#125; &#125;&lt;/script&gt; 事件处理方法然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在@事件中是不可行的。因此@事件还可以接收一个需要调用的方法名称。12345678910111213141516171819202122232425&lt;template&gt; &lt;view&gt; &lt;!-- `greet` 是在下面定义的方法名 --&gt; &lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; name: &apos;Vue.js&apos; &#125; &#125;, // 在 `methods` 对象中定义方法 methods: &#123; greet(event)&#123; // `event` 是原生 DOM 事件 console.log(event); uni.showToast(&#123; title: &apos;Hello &apos; + this.name + &apos;!&apos; &#125;); &#125; &#125; &#125;&lt;/script&gt; 内联处理器中的方法除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法：1234567891011121314151617&lt;template&gt; &lt;view&gt; &lt;button @click=&quot;say(&apos;hi&apos;)&quot;&gt;Say hi&lt;/button&gt; &lt;button @click=&quot;say(&apos;what&apos;)&quot;&gt;Say what&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; say(message) &#123; uni.showToast(&#123; title: message &#125;); &#125; &#125; &#125;&lt;/script&gt; 有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量$event把它传入方法：12345678910111213141516171819202122&lt;template&gt; &lt;view&gt; &lt;button @click=&quot;warn(&apos;Form cannot be submitted yet.&apos;, $event)&quot;&gt; Submit &lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; warn(message, event) &#123; // 现在我们可以访问原生事件对象 if (event) &#123; //可访问 event.target等原生事件对象 &#125; uni.showToast(&#123; title: message &#125;); &#125; &#125; &#125;&lt;/script&gt; 事件修饰符修饰符 (modifier)是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 @事件对于触发的事件调用 event.preventDefault()： @事件（v-on）提供了事件修饰符: .stop: 各平台均支持， 使用时会阻止事件冒泡，在非 H5 端同时也会阻止事件的默认行为.native: 监听原生事件，各平台均支持.prevent: 仅在 H5 平台支持.capture: 仅在 H5 平台支持.self: 仅在 H5 平台支持.once: 仅在 H5 平台支持.passive: 仅在 H5 平台支持 12&lt;!-- 阻止单击事件继续传播 --&gt;&lt;view @click.stop=&quot;doThis&quot;&gt;&lt;/view&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 @click.prevent.self 会阻止所有的点击，而 @click.self.prevent 只会阻止对元素自身的点击。注意 为兼容各端，事件需使用 @ 的方式绑定，请勿使用小程序端的 bind 和 catch 进行事件绑定；也不能在 JS 中使用event.preventDefault()和event.stopPropagation()方法； 若需要禁止蒙版下的页面滚动，可使用 @touchmove.stop.prevent=”moveHandle”，moveHandle 可以用来处理 touchmove 的事件，也可以是一个空函数。1&lt;view class=&quot;mask&quot; @touchmove.stop.prevent=&quot;moveHandle&quot;&gt;&lt;/view&gt; 按键修饰符：uni-app 运行在手机端，没有键盘事件，所以不支持按键修饰符。 事件映射表1234567891011121314151617181920212223// 事件映射表，左侧为 WEB 事件，右侧为 ``uni-app`` 对应事件 &#123; click: 'tap', touchstart: 'touchstart', touchmove: 'touchmove', touchcancel: 'touchcancel', touchend: 'touchend', tap: 'tap', longtap: 'longtap', //推荐使用longpress代替 input: 'input', change: 'change', submit: 'submit', blur: 'blur', focus: 'focus', reset: 'reset', confirm: 'confirm', columnchange: 'columnchange', linechange: 'linechange', error: 'error', scrolltoupper: 'scrolltoupper', scrolltolower: 'scrolltolower', scroll: 'scroll' &#125; 表单控件绑定v-model你可以用 v-model 指令在表单 input、textarea 及 select 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。 123456789101112131415&lt;template&gt; &lt;view&gt; &lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt; &lt;text&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; message:&quot;&quot; &#125; &#125; &#125;&lt;/script&gt; uni-app表单组件建议开发过程中直接使用 uni-app：表单组件。 用法示例：H5 的 select 标签用 picker 组件进行代替123456789101112131415161718192021222324&lt;template&gt; &lt;view&gt; &lt;picker @change=&quot;bindPickerChange&quot; :value=&quot;index&quot; :range=&quot;array&quot;&gt; &lt;view class=&quot;picker&quot;&gt; 当前选择：&#123;&#123;array[index]&#125;&#125; &lt;/view&gt; &lt;/picker&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; index: 0, array: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] &#125; &#125;, methods: &#123; bindPickerChange(e) &#123; console.log(e) &#125; &#125; &#125;&lt;/script&gt; 表单元素 radio 用 radio-group 组件进行代替123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;view&gt; &lt;radio-group class=&quot;radio-group&quot; @change=&quot;radioChange&quot;&gt; &lt;label class=&quot;radio&quot; v-for=&quot;(item, index) in items&quot; :key=&quot;item.name&quot;&gt; &lt;radio :value=&quot;item.name&quot; :checked=&quot;item.checked&quot; /&gt; &#123;&#123;item.value&#125;&#125; &lt;/label&gt; &lt;/radio-group&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; items: [&#123; name: &apos;USA&apos;, value: &apos;美国&apos; &#125;, &#123; name: &apos;CHN&apos;, value: &apos;中国&apos;, checked: &apos;true&apos; &#125;, &#123; name: &apos;BRA&apos;, value: &apos;巴西&apos; &#125;, &#123; name: &apos;JPN&apos;, value: &apos;日本&apos; &#125;, &#123; name: &apos;ENG&apos;, value: &apos;英国&apos; &#125;, &#123; name: &apos;TUR&apos;, value: &apos;法国&apos; &#125; ] &#125; &#125;, methods: &#123; radioChange(e) &#123; console.log(&apos;radio发生change事件，携带value值为：&apos;, e.target.value) &#125; &#125; &#125;&lt;/script&gt; 计算属性和侦听器计算属性computed每一个计算属性都包含一个 getter 和一个 setter ，默认是利用 getter 来读取。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。 计算属性的 getter123&lt;view&gt; &#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;/view&gt; 这里是想要显示变量 message 的翻转字符串。当你想要在模板中多包含此处的翻转字符串时，就会更加难以处理。所以，对于任何复杂逻辑，你都应当使用计算属性。123456789101112131415161718192021&lt;template&gt; &lt;view&gt; &lt;view&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/view&gt; &lt;view&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; message: &apos;Hello&apos; &#125; &#125;, computed: &#123; // 计算属性的 getter reversedMessage()&#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125; &#125;&lt;/script&gt; 结果：12Original message: \"Hello\"Computed reversed message: \"olleH\" 你可以像绑定普通 property 一样在模板中绑定计算属性。 Vue 知道 reversedMessage 依赖于 message，因此当 message 发生改变时，所有依赖 reversedMessage 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。 计算属性还可以依赖多个 Vue 实例的数据，只要其中任一数据变化，计算属性就会重新执行，视图也会更新。 计算属性的 setter在你需要时也可以提供一个 setter 函数， 当手动修改计算属性的值时，就会触发 setter 函数，执行一些自定义的操作。1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;view&gt; &lt;view&gt;&#123;&#123; fullName &#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos; &#125; &#125;, computed: &#123; fullName: &#123; // getter get()&#123; return this.firstName + &apos; &apos; + this.lastName &#125;, // setter set(newValue)&#123; var names = newValue.split(&apos; &apos;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125; &#125; &#125;&lt;/script&gt; 现在再运行 fullName = ‘John Doe’ 时，setter 会被调用，firstName 和 lastName 也会相应地被更新。 getter与setter区别 get：通过设置get方法可以得到fullName的新值。 set：通过set的方法，设置一个值（newValue）来改变fullName相关联的值，引起fullName重新的计算，相应的页面上fullName也会发生改变成新的内容 计算属性缓存 vs 方法我们可以通过在表达式中调用方法来达到同样的效果：12345678910111213141516171819&lt;template&gt; &lt;view&gt; &lt;view&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; message: &apos;Hello&apos; &#125; &#125;, methods: &#123; reversedMessage()&#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125; &#125;&lt;/script&gt; 可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。 只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖：12345computed: &#123; now()&#123; return Date.now() &#125; &#125; 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。 我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。 计算属性 vs 侦听属性Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch 。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。1234567891011121314151617export default &#123; data() &#123; return &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos;, fullName: &apos;Foo Bar&apos; &#125; &#125;, watch: &#123; firstName: function(val) &#123; this.fullName = val + &apos; &apos; + this.lastName &#125;, lastName: function(val) &#123; this.fullName = this.firstName + &apos; &apos; + val &#125; &#125;&#125; 上面代码是命令式且重复的。将它与计算属性的版本进行比较：12345678910111213export default &#123; data() &#123; return &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos; &#125; &#125;, computed: &#123; fullName()&#123; return this.firstName + &apos; &apos; + this.lastName &#125; &#125;&#125; 侦听器watch 类型：{ [key: string]: string | Function | Object | Array } 一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch() ，遍历 watch 对象的每一个 property 。1234567891011121314151617181920&lt;template&gt; &lt;view&gt; &lt;input type=&quot;text&quot; v-model=&quot;word&quot;&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; word: &apos;word&apos; &#125; &#125;, watch: &#123; /* 使用watch来响应数据的变化 */ word(newVal, oldVal) &#123; console.log(&apos;最新值是：&apos;+newVal,&quot;原来的值是：&quot;+ oldVal); &#125; &#125;, &#125;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;script&gt; export default &#123; data() &#123; return &#123; a: 1, b: 2, c: 3, d: 4, e: &#123; f: &#123; g: 5 &#125; &#125; &#125; &#125;, watch: &#123; a: function(val, oldVal) &#123; console.log('new: %s, old: %s', val, oldVal) &#125;, // 方法名 b: 'someMethod', // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深 c: &#123; handler: function(val, oldVal) &#123; /* ... */ &#125;, deep: true &#125;, // 该回调将会在侦听开始之后被立即调用 d: &#123; handler: 'someMethod', immediate: true &#125;, // 你可以传入回调数组，它们会被逐一调用 e: [ 'handle1', function handle2(val, oldVal) &#123; /* ... */ &#125;, &#123; handler: function handle3(val, oldVal) &#123; /* ... */ &#125;, /* ... */ &#125; ], // watch vm.e.f's value: &#123;g: 5&#125; 'e.f': function(val, oldVal) &#123; /* ... */ &#125; &#125; &#125;&lt;/script&gt; 附录：https://uniapp.dcloud.io/vue-basics","tags":[{"name":"前端","slug":"前端","permalink":"http://blog.feelyou.top/tags/前端/"}]},{"title":"必须做点什么！","date":"2021-05-27T13:35:47.000Z","path":"posts/2284308600.html","text":"心又开始躁动了，太多想法想要实现，但是，做的太少太少了。必须做点什么了！ blog已经闲置好久了，今天打开发现hexo g生成的public文件夹为空，部署失败。原因是hexo对nodejs14版本支持不太好，mvn版本管理可解，看样子工具得常用才行，斧子都锈了😅生锈的还有脑子和手，很久都没写文章了，手已经写不出脑子里想的东西了，脑子里面也是乱七八糟，不成结构，我也不知道我要写什么，可能你也看不到这篇文章，我就想到哪写到哪吧。 先说最急切的事情，免得待会写忘记。 开始写文章，不管写什么，坚持下笔； 把前端（uni-app）搞定，我必须得搞一个自己的app出来，我也不知道为了什么，可能是梦想吧； 好好搞数据比赛，机器学习和深度学习都得搞出点东西； 继续刷题，找个喜欢的工作； 现在（2021-05-27 22：07）blog处于空白状态，这周有时间hexo还得配置好，老方案 GitHub page + 腾讯云静态部署，这次搞妥了就好好别瞎懂了，每次要砍树就得修斧子，也是醉了。。。 最近微信公众号每天都会有几个人因为竹简ISBN联系到我，得抓紧把文档给整理好了，老版本的东西就删了，文档又不需要历史记录。另外，鉴权问题也得测试一下，这把锁得牢靠。官方主页也得做出来了，嗯，加油！ 技术视频，这个得提上议程了，摄像头都买了这么久，不用心疼，哈哈哈。 对了，还有坚持看书！三日不读书面目可憎🤡","tags":[]},{"title":"机器学习面试","date":"2021-04-22T10:37:21.000Z","path":"posts/705685184.html","text":"面试得刷题，得背八股文！ 41道 Machine Learning 高频面试题 超全机器学习算法岗面试与提问总结 BAT机器学习面试1000题系列","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://blog.feelyou.top/tags/机器学习/"},{"name":"面试","slug":"面试","permalink":"http://blog.feelyou.top/tags/面试/"}]},{"title":"Jupyter note问题汇总","date":"2021-04-21T08:00:48.000Z","path":"posts/3572944970.html","text":"jupyter note网页可打开，但是无法连接，大概率是jupyter note和tornado的版本不对应的问题。 12[C 15:45:42.277 LabApp] Bad config encountered during initialization:[C 15:45:42.277 LabApp] Could not decode '\\xe6\\x9c\\xaa\\xe5\\x91\\xbd\\xe5\\x90\\x8d' for unicode trait 'untitled_notebook' of a LargeFileManager instance. 大家提出解决方案： 1LANG=zn jupyter lab 可是这种方案会导致各类包引入，出现locale zn的错误，不可行！ My resolution: edit /usr/local/anaconda2/lib/python2.7/site.py file, change the function def setencoding line 481 from if 0 to if 1, so it will call sys.setdefaultencoding(encoding) edit /usr/local/anaconda2/lib/python2.7/site-packages/traitlets/traitlets.py file, change line 2050, from return value.decode(&#39;ascii&#39;, &#39;strict&#39;) to return value.decode(&#39;UTF-8&#39;, &#39;strict&#39;) 多版本：https://blog.csdn.net/C_chuxin/article/details/82690830","tags":[{"name":"python","slug":"python","permalink":"http://blog.feelyou.top/tags/python/"}]},{"title":"【leetcode】680.验证回文字符串Ⅱ","date":"2020-03-07T04:41:15.000Z","path":"posts/leetcode680.html","text":"链接：https://leetcode-cn.com/problems/valid-palindrome-ii 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 输入: “aba”输出: True 示例 2: 输入: “abca”输出: True解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 python3123456789101112class Solution: def validPalindrome(self, s: str) -&gt; bool: if s == s[::-1]: return True left, right = 0, len(s)-1 while left &lt; right: if s[left] == s[right]: left, right = left+1, right-1 else: a = s[left+1 : right+1] b = s[left : right] return a == a[::-1] or b == b[::-1]","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://blog.feelyou.top/tags/leetcode/"}]},{"title":"xgboost论文学习","date":"2020-03-04T03:15:35.000Z","path":"posts/3344740005.html","text":"什么是 XGBoostXGBoost 是陈天奇等人开发的一个开源机器学习项目，高效地实现了 GBDT 算法并进行了算法和工程上的许多改进。XGBoost本质上还是一个GBDT(Gradient Boosting Decision Tree)，但是将速度和效率发挥到极致，所以叫 X (Extreme) GBoosted。 TREE BOOSTING IN A NUTSHELLRegularized Learning Objective给定一个数据集 D 中有 n 个样本，每个样本有 m 维特征。通过训练数据集 D，我们得到 K 棵树。这 K 棵树累加的值为我们的预测值。 Boosting Tree的最终预测结果 其中$f_k(X_i)$是样本$X_i$在第 k 棵树的叶子上的权值。因此我们也可以这样定义。 样本$x_i$在第k棵树上的的权值 GBDT 通过经验函数最小化来确定预测函数的参数，XGBoost 在经验函数的基础上加上正则化项，其中$\\Omega$表示单棵树的正则化，正则化项表征了模型的复杂度，通过选择合适的参数限制模型复杂度，能够避免过拟合。 XGBoost的Loss Function 其中$l$是可导且凸的损失函数，用来衡量 ŷ 与 y 的相近程度，第二项 Ω 则是正则项，它包含了两个部分，第一个是 γT，这里的T表示叶子结点的数量，γ是超参(gamma 指定了节点分裂所需的最小损失函数下降值)，也就是说如果 γ 越大，那么我们的叶子结点数量就会越小。另外一部分则是L2正则项，通过对叶子结点的权重进行惩罚，使得不会存在权重过大的叶子结点防止过拟合。$\\omega$就表示叶子结点的权重。当$\\Omega=0$时，剩下的项就是 GBDT 的目标优化函数。 Gradient Tree BoostingGBDT 通过梯度下降法优化目标函数，梯度下降法是一种启发式优化算法，有可能陷入局部最优解。它们的不同之处是 XGBoost 优化的是经泰勒展开后近似的目标函数，该损失函数的推导如下，设：$\\hat{y_i}^t=y^{(t-1)}+f_t(X_i)$表示第 i 个实例在第 t 次迭代上的输出，第 t 次迭代的结果是产生第 t 颗树（boosting tree）。那么对第 t 颗树来说，其需要优化的目标函数将是如下： 提取出第t次迭代树的预测值，进行单独优化 对上式进行二阶泰勒展开得到如下的近似目标函数： 对$f_t(X_i)$进行二阶泰勒展开 其中，$g_i、h_i$分别是损失函数在当前模型的一阶和二阶偏导（gradient statistics）。当前模型已知，也就是当前模型对训练数据的误差已知，$l(y_i-\\hat{ y }^{(t-1)})$为常量，对目标函数的优化没有影响，移除得到如下的目标函数： 简化后的损失函数 定义叶子结点 j 上的实例集合为$I_j= { i|q(X_i)=j }$，对(3)进一步处理、展开可以得到(4)式 损失函数的关于ωj的二元函数 在(4)式中，目标函数对叶子结点权重求导，令导数=0，可以得到目标函数的解析最优解 极值点，叶子节点的权值 将解析解带入(4)式可以得到目标函数最优值 最优损失函数值 观察到最优解叶子结点 j 的权重$\\omega^*_j$其实是跟树的结构有关，换句话说就是训练数据集中有多少以及哪些数据分到叶子结点 j 上面有关，所以论文的后续大部分在讨论怎么确定树结构。论文是用(6)式作为scoring function来衡量树的好坏。树的生成主要是对于选定的 feature 怎么选择切分点，由于 CART 回归树采用二分法进行树生成，也就是对于选定的 feature 只选择一个切分点将数据分到切分点的两边，所以论文采用(7)式衡量切分点的增益。 分支判断 Shrinkage and Columns Subsampling除了以上提到了正则项以外，我们还有shrinkage与列采样技术来避免过拟合的出现。所谓shrinkage就是在每个迭代中树中，对叶子结点乘以一个缩减权重eta。该操作的作用就是减少每颗树的影响力，留更多的空间给后来的树提升。另一个技术则是采样的技术，有两种，一种是列采样(colsample_bytree和colsample_bylevel)，一种是行采样(subsample)。其中列采样的实现一般有两种方式，一种是按层随机 colsample_bylevel（一般来讲这种效果会好一点），另一种是建树前就随机选择特征 colsample_bytree。 按层随机 colsample_bylevel 的意思就是，每次分裂一个结点的时候，我们都要遍历所有的特征和分割点，从而确定最优的分割点，那么如果加入了列采样，我们会在对同一层内每个结点分裂之前，先随机选择一部分特征，于是我们只需要遍历这部分的特征，来确定最优的分割点。 建树前就随机选择特征 colsample_bytree 就表示我们在建树前就随机选择一部分特征，然后之后所有叶子结点的分裂都只使用这部分特征。 而行采样则是bagging的思想，每次只抽取部分的样本进行训练，而不使用全部的样本，从而增加树的多样性。 SPLIT FINDING ALGORITHMSBasic Exact Greedy Algorithmexact greedy algorithm是一种切分点查找算法，如 Algorithm 1 所示。该算法对于每一个 feature，试图枚举出所有可能的切分点，并计算在每一个切分点上的增益，从而选择增益最好的切分点。在 algorithm1 中要枚举出所有的可能的切分点，算法是首先对所有训练数据对 feature k 的取值进行排序，这样就能轻易地枚举出所有的切分点。 Approximate Algorithmexact greedy algorithm 很强大，但当训练数据量太大以至于无法完全读进内存或者运行在分布式计算资源上，就有问题了。所以论文总结了一种approximate algorithm 针对 feature k 先是根据特征分布的percentile列出了 L 个待选切分点（candidate splitting point），切分点值的集合$S_k$，之后根据(7)式分别计算这些待选切分点的增益，选择增益最好的切分点。根据 feature k 大小不同——是在训练的一开始就对全部训练数据的 feature k 列出待选切分点还是对分到某个结点上的训练数据的 feature k，approximate algorithm 有两种变体——global、local. Weight Quantile Sketch加权分位数（weighted quantile）用于上述提到的待选切分点（percentile）的选择。具体来说，假设有数据集$Dk={(x{1k},h1),(x{2k},h2),···,(x{nk},h_n)}$，表示实例 1、2、…、n 的特征 k 的值和其二阶偏导，则有如(8)所示的rank function，根据该 rank function 选择待选切分点。加权的意思 rank function 是用二阶偏导计算，也就是给每个实例以权重，该权重是实例点的二阶偏导。(8)式 rank function 表示对于特征 k，小于 z 的实例占总数的比重，这里的总数根据 global 还是 local 而定。 用于分裂排序的Rank 根据需要选择的待选切分点数量$1/\\epsilon$，我们可以得到分位数$S_k$. 定义eps用于设置最大的 max_depth最大树深度：当树达到最大深度时则停止建立决策树。min_child_weight: 最小的样本权重和，样本权重和就是$\\sum h_i$，当样本权重和小于设定阈值时则停止建树。 $\\sum_{i=1}^n\\frac{1}{2}h_i(f_i(X_i)-g_i/h_i)^2+\\Omega(f_t)+constant$ ，其中$g_i/h_i$表示 labels，$h_i$表示样本权重。 Sparsity-aware Split Finding在实际场景中，数据缺失很常见，如果某实例点的特征值缺失，上述算法无法将该实例点分到任一子结点。对此论文提出了稀疏感知的切分点查找算法。原理大概是对于特征值缺失的实例点，基于这个分裂的评分函数，分别将其分到左右子结点$I_L$和$I_R$两边计算两个评分，计算增益，选择增益最好的划分方式作为该特征缺失情况下的默认划分。 XGBoost 与 GBDT 有什么不同除了算法上与传统的 GBDT 有一些不同外，XGBoost 还在工程实现上做了大量的优化。总的来说，两者之间的区别和联系可以总结成以下几个方面。 GBDT是机器学习算法，XGBoost是该算法的工程实现； 在使用CART作为基分类器时，XGBoost 显式地加入了正则项来控制模型的复杂度，有利于防止过拟合，从而提高模型的泛化能力； GBDT 在模型训练时只使用了代价函数的一阶导数信息，XGBoost 对代价函数进行二阶泰勒展开，可以同时使用一阶和二阶导数，二阶导数有利于梯度下降的更快更准. 使用泰勒展开取得函数做自变量的二阶导数形式, 可以在不选定损失函数具体形式的情况下, 仅仅依靠输入数据的值就可以进行叶子分裂优化计算, 本质上也就把损失函数的选取和模型算法优化/参数选择分开了。这种去耦合增加了 XGBoost 的适用性, 使得它按需选取损失函数, 可以用于分类, 也可以用于回归； 传统的 GBDT 采用 CART 作为基分类器，XGBoost 支持多种类型的基分类器，比如线性分类器； 传统的 GBDT 在每轮迭代时使用全部的数据，XGBoost 则采用了与随机森林相似的策略，支持对数据进行采样； 传统的 GBDT 没有设计对缺失值进行处理，XGBoost 能够自动学习出缺失值的处理策略。 工程系统设计上的优化 利用列块进行并行计算； 缓存处理能力； 数据块以外的计算力提高。 XGBoost 重要参数通用参数 booster：gbtree 和 gblinear。gbtree是采用树的结构来运行数据，而gblinear是基于线性模型。 silent：静默模式，为1时模型运行不输出。 nthread: 使用线程数，数值型，-1 为使用所有线程。 Booster 参数 控制每一步的 booster(tree/regression)。booster 参数一般可以调控模型的效果和计算代价。我们所说的调参，很这是大程度上都是在调整 booster 参数。 n_estimator: 也作num_boosting_rounds，这是生成的最大树的数目，也是最大的迭代次数； learning_rate: 也作eta，系统默认值为0.3。每一步迭代的步长，太大了运行准确率不高，太小了运行速度慢。一般使用0.1左右； min_child_weight: 默认值 1，决定最小叶子节点样本权重和。这个值可以理解为H值，就是损失函数对$y_{ (t-1) }$的二阶导数和，那么如果损失函数是平方函数（回归问题），这个就是 1；如果是对数损失函数（分类问题），导数是 a(1-a)的形式，a 代表sigmoid函数，这样的话当 y 预测值非常大的时候，这个式子的值接近于 0，因此需要设定一个阈值，小于这个阈值就不分裂了。这个值代表所有样本二阶导数的和，和叶子得分不是一个事，如果是回归问题实际代表样本个数，如果是分类问题实际代表 a(1-a)所有样本计算值的加和。这个参数用于避免过拟合，当它的值较大时，可以避免模型学习到局部的特殊样本。举个栗子来说，对正负样本不均衡时的 0-1 分类而言，假设 h 在 0.01 附近，min_child_weight 为 1 意味着叶子节点中最少需要包含 100 个样本，实际是通过控制样本数来控制过拟合的。 gamma：系统默认为 0,我们也常用 0。在节点分裂时，只有分裂后损失函数的值下降了，才会分裂这个节点。gamma 指定了节点分裂所需的最小损失函数下降值。 这个参数的值越大，算法越保守。因为 gamma 值越大的时候，损失函数下降更多才可以分裂节点。所以树生成的时候更不容易分裂节点。范围: [0,∞]； subsample：系统默认为 1。这个参数控制对于每棵树，随机采样的比例。减小这个参数的值，算法会更加保守，避免过拟合。但是，如果这个值设置得过小，它可能会导致欠拟合。 典型值：0.5-1，0.5 代表平均采样，防止过拟合. 范围: (0,1]，注意不可取 0； colsample_bytree：系统默认值为 1。我们一般设置成0.8左右。用来控制每棵随机采样的列数的占比(每一列是一个特征)。 典型值：0.5-1，范围: (0,1]； colsample_bylevel：默认为 1,我们也设置为 1。这个就相比于colsample_bytree更加细致了，它指的是每棵树每次节点分裂的时候列采样的比例； max_depth： 系统默认值为 6，我们常用 3-10 之间的数字。这个值为树的最大深度。这个值是用来控制过拟合的。max_depth 越大，模型学习的更加具体。设置为 0 代表没有限制，范围: [0,∞]; max_leaf_nodes: 树上最大节点的数量，和上面的那个参数一样，如果定义了这个参数就会忽略掉 max_depth 参数，我们调优还是以 max_depth 为主吧； max_delta_step：默认 0,我们常用 0。这个参数限制了每棵树权重改变的最大步长，如果这个参数的值为 0,则意味着没有约束。如果他被赋予了某一个正值，则是这个算法更加保守。通常，这个参数我们不需要设置，但是当各类别的样本极不平衡的时候，这个参数对逻辑回归优化器是很有帮助的; lambda:也称 reg_lambda,默认值为 0。权重的L2正则化项(和 Ridge regression 类似)。这个参数是用来控制 XGBoost 的正则化部分的。这个参数在减少过拟合上很有帮助。 alpha:也称 reg_alpha 默认为 0,权重的L1正则化项(和 Lasso regression 类似)。 可以应用在很高维度的情况下，使得算法的速度更快; scale_pos_weight：默认为 1，在各类别样本十分不平衡时，把这个参数设定为一个正值，可以使算法更快收敛。通常可以将其设置为负样本的数目与正样本数目的比值，sum(negative cases) / sum(positive cases) 。 tree_method: [default=’auto’]有三个可选的值， {‘auto’, ‘exact’, ‘approx’} ，分别对应 贪心算法(小数据集)/近似算法(大数据集) 。 学习目标参数 控制训练目标的表现。我们对于问题的划分主要体现在学习目标参数上。比如我们要做分类还是回归，做二分类还是多分类，这都是目标参数所提供的。 seed: (default=0)，这个叫随机数种子，这个参数就是为了可以使结果复现。 objective [缺省值=reg:linear] reg:linear – 线性回归 reg:logistic – 逻辑回归 binary:logistic – 二分类逻辑回归，输出为概率 binary:logitraw – 二分类逻辑回归，输出的结果为 wTx count:poisson – 计数问题的 poisson 回归，输出结果为 poisson 分布。在 poisson 回归中，max_delta_step 的缺省值为 0.7 (used to safeguard optimization) multi:softmax – 设置 XGBoost 使用 softmax 目标函数做多分类，需要设置参数 num_class（类别个数） multi:softprob – 如同 softmax，但是输出结果为 ndata*nclass 的向量，其中的值是每个数据分为每个类的概率。 eval_metric [缺省值=通过目标函数选择] rmse: 均方根误差 mae: 平均绝对值误差 logloss: negative log-likelihood error: 二分类错误率。其值通过错误分类数目与全部分类数目比值得到。对于预测，预测值大于 0.5 被认为是正类，其它归为负类。 error@t: 不同的划分阈值可以通过 ‘t’进行设置 merror: 多分类错误率，计算公式为(wrong cases)/(all cases) mlogloss: 多分类 log 损失 auc: 曲线下的面积 ndcg: Normalized Discounted Cumulative Gain map: 平均正确率 目录： https://xgboost.readthedocs.io/en/latest/parameter.html https://blog.csdn.net/a358463121/article/details/68617389 https://www.cnblogs.com/mantch/p/11164221.html https://github.com/NLP-LOVE/ML-NLP/blob/master/Machine%20Learning/3.2%20GBDT/3.2%20GBDT.md","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://blog.feelyou.top/tags/机器学习/"}]},{"title":"【leetcode】125.验证回文串","date":"2020-03-04T02:52:28.000Z","path":"posts/leetcode125.html","text":"链接：https://leetcode-cn.com/problems/valid-palindrome 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: “A man, a plan, a canal: Panama”输出: true 示例 2: 输入: “race a car”输出: false python31234class Solution: def isPalindrome(self, s: str) -&gt; bool: s = [*filter(str.isalnum, s.lower())] return s == s[::-1] 学到两个很牛逼方法：filter: 过滤方法12345678#!/usr/bin/python# -*- coding: UTF-8 -*- def is_odd(n): return n % 2 == 1 newlist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])print(newlist) *: 解包123[*range(5)][i for i in range(5)][0, 1, 2, 3, 4]","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://blog.feelyou.top/tags/leetcode/"}]},{"title":"Mac搭建配置Arduino环境，详细步骤，国内资源","date":"2020-02-25T08:12:07.000Z","path":"posts/734455085.html","text":"Arduino Mac上环境搭建​ 从角落里翻出以前的Wi-Fiduino，吃灰了好久，想重新拯救它。可是，Arduino编辑器没了，得重新安装。查了一晚上Arduino环境配置文档，感觉大家都在用win，Mac在这个圈并不受欢迎。。。了解了安装配置过程，然鹅，Arduino的所有资源都在GitHub上，从GitHub上下载一百多M的安装包，这不是个简单的事情。经过一天半的奋斗，终于想办法把它们都弄下来了。哈哈哈，不容易。我也知道有很多刚入门arduino的小伙伴也有这样的苦恼，下面把安装配置过程整理了一遍，希望对你有帮助。 0 1、安装 ArduinoArduino 和esp8266开发板 下载链接:https://pan.baidu.com/s/1mO8NVgCIuy1PE42iBSnsag ,关注微信公众号：正版乔，回复“Arduino”获取离线安装包密码。 2、首选项 command+,​ 配置索引地址：https://arduino.esp8266.com/stable/package_esp8266com_index.json 3、打开开发板管理器 4、安装8266 ​选择版本“2.6.3”点击“安装”，可以看到arduino安装目录：/Users/你的电脑/Library/Arduino15/下出现staging文件夹，packages文件夹中正在下载esp8266-2.6.3.zip，不用等了，现有网络它是下载不完的。直接将我提供的packages文件夹里的几个压缩包放在路径下，和下图一样哟。重启Arduino客户端，然后再次来到开发板管理器，搜‘8266’， 选择版本“2.6.3”点击“安装”，它就会飞速安装。这时候你就可以在开发板中看到你需要的8266了！","tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://blog.feelyou.top/tags/树莓派/"}]},{"title":"考研复试","date":"2020-02-18T14:06:12.000Z","path":"posts/1913976338.html","text":"本来想等疫情结束后再更新文章的，把本以纷乱复杂、有限的舆论渠道留给最需要的人们。疫情阻挡了我们生活的脚步，按下了暂停键，但是，生活还是要继续，梦想还要坚持。 2020一切都变的非常突然，突如其来的新冠肺炎打乱了所有人的计划。祖国各地医护人员奔赴湖北，防疫抗疫。全国同胞在家自我隔离，口罩成了硬通货；中小学学生们的寒假假期被延长，老师们被迫当上主播；在家办公成为当前最主流的办公方式； 2月底，各学校陆续公布考研初试成绩和复试安排。准备了一两年的考研到了结果的时候，最近有很多同学咨询我关于考研复试的问题，我在这里整理了一份相关问题的解答，希望对你能有帮助。 什么是复试研究生录取考试分为初试和复试。初试以政治、英语、数学（部分为联考）、专业课四门功课笔试为主，评判标准为四门考试的总分排名，根据该学校此专业当年考生招生计划，以120%～200%的录取人数划出当年此专业的初试分数线。同时各学校可能按照专业定位对单一课程的分数作出要求，比如，某校某专业要求英语分数不低于60分，数学分数不低于70分等。对于这些对课程单独分数规定的，首先看单独课程分数是否过线，如果单独分数低于要求，总分再高也没办法进入复试；在单独分数均满足学校要求后，比较四门总分是否满足学校公布的初试分数线。都满足了，恭喜你欢迎进入决赛圈！在学校正式公布初试分数线之前，所有小道消息都只是会引起你无谓的焦虑，自己按规划做好准备即可，即使没过线复试准备在调剂过程中也是一样重要。 复试一般包括什么大家通过了将近一年的初试准备，初试过线就已证明你的专业能力和学习能力，自信点，哈哈哈～复试阶段，各学校根据招生计划进行笔试和面试。各个专业复试计划不同，详情请查看学院公布的复试通知。当年统计学院只有面试，保险学院好像笔试+面试，我觉得如果专业复试比例比较高的时候，一般会采用笔试+面试的方式，笔试面试分数一般四六开，提高筛选稳定性，这时候就得好好准备复试简章里提到知识点，认真复习，初试成绩比较低的同学可以在这次笔试中翻盘；在复试比例不高的时候，老师默认为初试成绩已经说明你已符合就读研究生专业知识，而且大多数情况下，分数差距在10分以内的同学没有差距，这个时候提高面试能力相当重要。 面试中一般有以下几个方面： 自我介绍（面试最重要的一环，这个时候就要把你的适应货都亮出来了，这段介绍决定了老师和你讨论问题的方向和角度）； 专业知识问答（提问式的考察专业的基础知识，不会太难，让你适应面试节奏）； 专业内问题讨论（老师可能会提出一些领域内的问题，抱着交流学习的心态聊就可以）； 英语问答（作为研究生，英语表述能力也是非常重要的。但不是最重要的，专业为主，一般情况老师的提问已固定，照着准备就好）. 我该怎么准备复试由于本人复试只有一场面试，这里只能和大家分享一下面试经验，复试中的笔试按照复试简章，保持考研状态就应该能搞定。复试的选拔一般考量地是学生的综合素质，比如，专业素养、沟通交流、抗压能力、个人性格等。怎么对付，我分享一下我的经验。 着装花30秒想象一下，你觉得一个研究生该是什么样子。对，就是普通、学术，穿着上不应该来抢镜。普通的休闲装，看起来有精神的衣服，不要太臃肿复杂，颜色不要太丰富，保持干净整洁很重要。这些天疫情影响，理发店都没开门，可能大家都成了F4，不过在面试前请处理好你非主流的发型。看到有些同学穿了一套西服面试，可以是可以，也表现了你对面试的重视。不过要考虑的一点是，你习惯穿西服吗，有些同学以前从来没有西服，没有找到穿西服的感觉，拘谨，如果是链家的感觉，我建议你还是穿你习惯的衣服。朴素即自信！ 心态和气质我觉得气质心态在复试中是最重要的一点。讲个故事，我当年复试由于附近酒店紧张，找了一个青旅（其实青旅很冒险，可能会导致你休息不好）。好在这个青旅的大多数租客都是贸大考研复试的同学，在这里就有两种截然不同的人，一种是我上铺的朋友，每天早上六七点起床去学校教室复习，晚上10点多才回来，躺床上还在背记；另一种就是我这类人，我们几个在相互介绍过后，就开始吐槽自己的故事，听别人的故事，一起出去吃饭，一起吹牛逼，哈哈哈。互相提一些问题讨论，随意讨论，没有答案。结果呢，，，结果那几个认真复习，不张嘴的同学被淘汰了，我们那群每天乱侃的同学录取了。这可能是幸存者偏差，不过我想说的是面试是一个需要交流的考试，张嘴说话很重要。一起吃饭、一起吹牛逼，让第一次来北方的我慢点熟悉了环境，有一种我在这边有朋友的感觉，这种心态很重要。如果你对这个城市、这个学校很陌生的话，一定要提前逛逛，和路人聊，和学校的学生聊，这里的一切将和你有关。交流可以慢点理顺你的思维，明确你的优缺点，一直生活在南方的我，一口自己都嫌弃的普通话，每次和别人说话都会被问是哪里人，第一次被问的时候还是挺打击的，和别人聊多了，就会发现普通话标准当然好，但普通话不标准也没有影响我表达我的观点，大家的讨论都是基于观点的。疫情影响，我感觉我都快自闭了，我想大家的心态都没有以前那么open了，我的建议是多找说话的机会，说什么都行，给你好久没联系的朋友拨个电话吧，聊聊你会好一点。自信点，那是你的学校，你的老师，不要虚！ 自我介绍这是你面试的第一步，把握好。首先，文明礼貌应该不用说，很多时候细节才是重点。进考室会紧张，是非常正常的，想办法让自己calm down。环顾老师一周，和所有老师坚定友善的对视一下，视线握手🤝自我介绍应该在复试前准备好发言稿，三到五分钟，包括 自己的个人情况：姓名、籍贯、本科学校、专业； 本科期间的一些学术方向的研究，论文发表、特牛的奖学金等等。什么，什么都没有，正常！这就是要提前准备的必要性，初试准备你应该已经知道这个专业到底需要什么技能、什么样的学生了，对比你本科期间学习的课程和自己研究的东西，找到其中的相关性。比如我本科是学信息与计算科学的，数学+计算机，考统计，我想把我本科所学的数学和计算机知识与统计结合起来，朝数据挖掘工程师的方向发展。我做过一些相关的爬虫、数据分析等等。让老师知道你读这个专业是有准备的，有方向的。其他跨考的同学也可好好想想两个专业结合的发展方向，说明读研的必要性；学生工作的话，如果很重要的话，可以提一两句，这是招研究生不是招干部。（注意，很重要的一点是，你所描述的任何事情都应该是你做过你了解的，因为你现在的介绍就是你待会的考试范围。） 对研究生生活有清晰的规划。统计专业，懂得大数据相关知识，比如大数据的定义、特点，对工作生活带来的影响等。老师想要的是合作伙伴，不是单纯会读书的学生。 说出你的故事。可以说说你为什么想要来这里读研，你的梦想。表达感情，这很重要，前面的艰苦复习没有放弃，不是简单想读个研的，想想你为何出发。表达热爱、说出憧憬和对老师的尊敬是很好的结尾方式。老师们会以同等的感情带你进入下一环节的。 专业讨论首先重复一遍问题，为自己争取思考的时间。尽可能把问题和答案描述清楚，思路最重要。可能你会碰到一些对你比较困难的问题，这是先表明态度，对这个方向的研究不太深入，只能抱着学习的态度和老师们探讨，大神面前不懂装懂是很危险，从最基础的知识点说起，从你了解的角度把问题扩展，将老师的关注点引导到你擅长的地方。主动和老师介绍你关注的领域，对领域研究有一定的看法，老师会喜欢和你探讨下去的。 英语问答据我了解，有些学院英语面试是邀请英语学院的老师和学生进行英语问答，这时候老师对专业方向的知识可能没那么清楚，提前准备一份本专业相关的英语介绍，不用太深入。很大的可能和你聊一些你的本科生活、你的梦想、你为什么要来这里读研等等。如果是学院老师进行英语问答，可能会让你用英语描述一些本专业的基础知识，了解清楚专业单词很重要。不过，也不用太对英语面试害怕，背一两段常考问题就OK！在对话栏里发送：复试英语，我整理了一些你应该用得上的资料。 面试最重要的就是聊下去，不跋扈不卑微，自信的聊，不冷场，那就问题不大！ 我需要报复试班吗？不需要！！！以过来人和多次拒绝给复试同学培训邀约的身份告诉你，不需要。一路走来，你已经很棒了，虽然你现在很慌，但是不需要在一些不必的地方浪费时间和金钱。 没过学校初试分数线，我还有其他选择吗？ 调剂 二战 考公务员 就业","tags":[{"name":"考研","slug":"考研","permalink":"http://blog.feelyou.top/tags/考研/"}]},{"title":"豆瓣读书3.0 —— 书名列表查询📖","date":"2020-02-10T09:51:39.000Z","path":"posts/3057611655.html","text":"前两版本请见：https://github.com/qiaohaoforever/DoubanBook 书名查询调用地址：https://book.feelyou.top/search/ 请求方式：GET 返回类型：JSON 请求示例：https://book.feelyou.top/search/深度学习 请求参数（Query） 名称 类型 是否必须 描述 书名 STRING 必选 图书名称 返回参数图书信息列表为list格式，每一本书对应一个json。 字段 名称 类型 示例 title 书名 str “深度学习” id douban书籍编码 int 27087503 cover_url 封面图片 str “https://img3.doubanio.com/view/subject/l/public/s29518349.jpg“ topics 话题 list [] labels 标签 list [] abstract 简介 str “[美] 伊恩·古德费洛 / [加] 约书亚·本吉奥 / [加] 亚伦·库维尔 / 赵申剑 / 黎彧君 / 符天凡 / 李凯 / 人民邮电出版社 / 2017-7-1 / 168” url 图书页面 str “https://book.douban.com/subject/27087503/“ rating 评分 dict {“count”: 839,”rating_info”: “”,”star_count”: 4,”value”: 8.3} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166[ &#123; &quot;tpl_name&quot;: &quot;search_simple&quot;, &quot;title&quot;: &quot;[丛书] 深度学习系列&quot;, &quot;abstract&quot;: &quot;;机械工业出版社;清华大学出版社 / 共11册&quot;, &quot;url&quot;: &quot;https://book.douban.com/series/45479&quot;, &quot;id&quot;: 45479, &quot;labels&quot;: [ ] &#125;, &#123; &quot;tpl_name&quot;: &quot;search_subject&quot;, &quot;title&quot;: &quot;深度学习&quot;, &quot;id&quot;: 27087503, &quot;cover_url&quot;: &quot;https://img3.doubanio.com/view/subject/l/public/s29518349.jpg&quot;, &quot;topics&quot;: [ ], &quot;label_actions&quot;: [ ], &quot;labels&quot;: [ ], &quot;abstract&quot;: &quot;[美] 伊恩·古德费洛 / [加] 约书亚·本吉奥 / [加] 亚伦·库维尔 / 赵申剑 / 黎彧君 / 符天凡 / 李凯 / 人民邮电出版社 / 2017-7-1 / 168&quot;, &quot;url&quot;: &quot;https://book.douban.com/subject/27087503/&quot;, &quot;abstract_2&quot;: &quot;&quot;, &quot;extra_actions&quot;: [ ], &quot;interest&quot;: null, &quot;more_url&quot;: &quot;onclick=\\&quot;moreurl(this,&#123;i:&apos;0&apos;,query:&apos;%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0&apos;,subject_id:&apos;27087503&apos;,from:&apos;book_subject_search&apos;,cat_id:&apos;1001&apos;&#125;)\\&quot;&quot;, &quot;rating&quot;: &#123; &quot;count&quot;: 839, &quot;rating_info&quot;: &quot;&quot;, &quot;star_count&quot;: 4, &quot;value&quot;: 8.3 &#125; &#125;, &#123; &quot;id&quot;: 30293801, &quot;title&quot;: &quot;Python深度学习&quot;, &quot;cover_url&quot;: &quot;https://img3.doubanio.com/view/subject/l/public/s29839337.jpg&quot;, &quot;labels&quot;: [ ], &quot;label_actions&quot;: [ ], &quot;extra_actions&quot;: [ ], &quot;rating&quot;: &#123; &quot;value&quot;: 9.6, &quot;count&quot;: 461, &quot;rating_info&quot;: &quot;&quot;, &quot;star_count&quot;: 5 &#125;, &quot;abstract&quot;: &quot;[美] 弗朗索瓦•肖莱 / 张亮 / 人民邮电出版社 / 2018-8 / 119.00元&quot;, &quot;topics&quot;: [ ], &quot;more_url&quot;: &quot;onclick=\\&quot;moreurl(this,&#123;i:&apos;1&apos;,query:&apos;%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0&apos;,subject_id:&apos;30293801&apos;,from:&apos;book_subject_search&apos;,cat_id:&apos;1001&apos;&#125;)\\&quot;&quot;, &quot;url&quot;: &quot;https://book.douban.com/subject/30293801/&quot;, &quot;abstract_2&quot;: &quot;&quot;, &quot;tpl_name&quot;: &quot;search_subject&quot;, &quot;interest&quot;: null &#125;, &#123; &quot;more_url&quot;: &quot;onclick=\\&quot;moreurl(this,&#123;i:&apos;2&apos;,query:&apos;%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0&apos;,subject_id:&apos;33450010&apos;,from:&apos;book_subject_search&apos;,cat_id:&apos;1001&apos;&#125;)\\&quot;&quot;, &quot;cover_url&quot;: &quot;https://img3.doubanio.com/view/subject/l/public/s32322795.jpg&quot;, &quot;labels&quot;: [ ], &quot;topics&quot;: [ ], &quot;interest&quot;: null, &quot;title&quot;: &quot;动手学深度学习&quot;, &quot;tpl_name&quot;: &quot;search_subject&quot;, &quot;rating&quot;: &#123; &quot;value&quot;: 9.3, &quot;count&quot;: 109, &quot;star_count&quot;: 4.5, &quot;rating_info&quot;: &quot;&quot; &#125;, &quot;label_actions&quot;: [ ], &quot;abstract&quot;: &quot;阿斯顿·张（Aston Zhang） / 李沐（Mu Li） / [美] 扎卡里·C. 立顿（Zachary C. Lipton） / [德] 亚历山大·J. 斯莫拉（Alexander J. Smola） / 人民邮电出版社 / 2019-6 / 85.00元&quot;, &quot;url&quot;: &quot;https://book.douban.com/subject/33450010/&quot;, &quot;abstract_2&quot;: &quot;&quot;, &quot;extra_actions&quot;: [ ], &quot;id&quot;: 33450010 &#125;, &#123; &quot;extra_actions&quot;: [ &#123; &quot;color&quot;: &quot;#CF5B40&quot;, &quot;text&quot;: &quot;豆瓣书店有售&quot;, &quot;url&quot;: &quot;https://book.douban.com/subject/30425822/?channel=subject_list&amp;platform=web&quot; &#125;, &#123; &quot;color&quot;: &quot;#973F31&quot;, &quot;text&quot;: &quot;豆瓣阅读电子版&quot;, &quot;url&quot;: &quot;https://read.douban.com/ebook/107186317/?dcs=search-buylink&amp;dcm=douban&amp;dct=30425822&quot; &#125; ], &quot;tpl_name&quot;: &quot;search_subject&quot;, &quot;abstract&quot;: &quot;[美]特伦斯·谢诺夫斯基（Terrence Sejnowski） / 姜悦兵 / 中信出版集团 / 2019-2 / 88&quot;, &quot;id&quot;: 30425822, &quot;more_url&quot;: &quot;onclick=\\&quot;moreurl(this,&#123;i:&apos;3&apos;,query:&apos;%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0&apos;,subject_id:&apos;30425822&apos;,from:&apos;book_subject_search&apos;,cat_id:&apos;1001&apos;&#125;)\\&quot;&quot;, &quot;topics&quot;: [ ], &quot;cover_url&quot;: &quot;https://img3.doubanio.com/view/subject/l/public/s29971614.jpg&quot;, &quot;label_actions&quot;: [ ], &quot;interest&quot;: null, &quot;url&quot;: &quot;https://book.douban.com/subject/30425822/&quot;, &quot;rating&quot;: &#123; &quot;rating_info&quot;: &quot;&quot;, &quot;count&quot;: 403, &quot;star_count&quot;: 4, &quot;value&quot;: 7.6 &#125;, &quot;title&quot;: &quot;深度学习 : 智能时代的核心驱动力量&quot;, &quot;abstract_2&quot;: &quot;&quot;, &quot;labels&quot;: [ ] &#125;, &#123; &quot;topics&quot;: [ ], &quot;id&quot;: 26976457, &quot;title&quot;: &quot;Tensorflow：实战Google深度学习框架&quot;, &quot;interest&quot;: null, &quot;label_actions&quot;: [ ], &quot;abstract_2&quot;: &quot;&quot;, &quot;labels&quot;: [ ], &quot;abstract&quot;: &quot;郑泽宇 / 顾思宇 / 电子工业出版社 / 2017-2-10 / 79&quot;, &quot;rating&quot;: &#123; &quot;star_count&quot;: 4, &quot;count&quot;: 267, &quot;rating_info&quot;: &quot;&quot;, &quot;value&quot;: 8 &#125;, &quot;extra_actions&quot;: [ ], &quot;cover_url&quot;: &quot;https://img3.doubanio.com/view/subject/l/public/s29349250.jpg&quot;, &quot;more_url&quot;: &quot;onclick=\\&quot;moreurl(this,&#123;i:&apos;4&apos;,query:&apos;%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0&apos;,subject_id:&apos;26976457&apos;,from:&apos;book_subject_search&apos;,cat_id:&apos;1001&apos;&#125;)\\&quot;&quot;, &quot;tpl_name&quot;: &quot;search_subject&quot;, &quot;url&quot;: &quot;https://book.douban.com/subject/26976457/&quot; &#125;]","tags":[{"name":"api","slug":"api","permalink":"http://blog.feelyou.top/tags/api/"},{"name":"nodejs","slug":"nodejs","permalink":"http://blog.feelyou.top/tags/nodejs/"},{"name":"python","slug":"python","permalink":"http://blog.feelyou.top/tags/python/"}]},{"title":"calculus made easy","date":"2019-12-18T08:39:13.000Z","path":"posts/calculusmadeeasy.html","text":"NO.1 TO DELIVER YOU FROM THE PRELIMINARY TERRORS(1) d which merely means “a little bit of.”Thus dx means a little bit of x; or du means a little bit of u. Ordinary mathematicians think it more polite to say “an element of,” instead of “a little bit of.” Just as you please. But you will find that these little bits (or elements) may be considered to be indefinitely small. (2) ∫ which is merely a long S, and may be called (if you like) “the sum of.”Thus ∫dx means the sum of all the little bits of x; or ∫dt means the sum of all the little bits of t. Ordinary mathematicians call this symbol “the integral of.” Now any fool can see that if x is considered as made up of a lot of little bits, each of which is called dx, if you add them all up together you get the sum of all the dx’s, (which is the same thing as the whole of x). The word “integral” simply means “the whole.” If you think of the duration of time for one hour, you may (if you like) think of it as cut up into 3600 little bits called seconds. The whole of the 3600 little bits added up together make one hour. NO.2 ON DIFFERENT DEGREES OF SMALLNESS","tags":[]},{"title":"【UIBE】考研考试前，我该做些什么？","date":"2019-12-18T06:22:35.000Z","path":"posts/uibe_before_test.html","text":"梦想就在前方，再跨一步就能到达。考研的同学们，请务必加油！ 回想4年前的今天，坐在图书馆里的我，紧张于即将来临的考试，期待于每天憧憬的未来。大半年的复习生活，我学会了很多，学会了早起抢座位；学会了在室友组团开黑的时候，忍受孤独；学会了如何面对做对题的欣喜和做错题的沮丧；学会了如何规划自己的未来，并一步一步向它努力。我很感谢考研给我带来的一切，除了结果，还有一种内化于心的坚韧品质。 我知道你这几天可能有点“方”，可能有点忙，和你说几句，希望可以帮到你。 保持习惯最后几天最重要的就是保持状态，经历了这么多天的学习生活，你已经有了自己的节奏，保持平常心，按习惯的节奏学习、吃饭、睡觉。不要尝试在最近搞大动作，放轻松，从确认报名开始，每天都有人在退出，我想你可能这些天也看到了一些人在最后的时候选择放弃。你要做的就是把准备考研这些个月的积累展现出来就行。到正式开考，你已经淘汰掉了20%左右的报考对手。 提前考察考场环境，备好考试证件提前考察考场，做好后勤准备。座椅位置，教室灯光，看不到钟就带一块表，多打印几分证件。南方的教室空调可能不太好，我当时就在边搓手边答题。不过，贸大暖气充足，等你来！ 生物钟调整每场考试都在3个小时左右，没有提前模拟会不太适应。这几天，可以严格按照考试时间做一些真题模拟，把自己调整到考试状态。中午有午睡习惯的同学也得做好考试当天的安排，我当时就在考场旁的图书馆趴了一会。开始考试，请务必打起十二分的精神。这么多个日日夜夜争取来的3小时考试时间不要浪费，认真做好每一道题，对待每一分钟。 明确考场局势考研考场和高考不一样，大家可能来自不同专业，你的前排可能是考哲学的，后面可能是考理论物理的。除专业课外，大家没有可比性，做自己的题，按照自己的节奏面对考试。在我同一考场，有的同学3个小时不停的奋笔疾书；有的同学一个小时就搞定了，趴着睡了两个小时；有的同学前期没有准备好，进场就趴着，等着提前交卷。更多地，你会发现每一场考试结束，教室里的人就会少一些，所以，报录比并不是参考的标准，完整参加考试才算参与比赛。认真考完考试，你就已经淘汰掉了百分之四五十的对手。 最后一门考试未结束，一切都不能下定论数学，英语，这两场考试后大家都会抱怨，有些人说没戏了，下面的不想再考了；有些人会告诉你自己考的不错，押到题了。放轻松，考研最终成绩是四门总和，正常发挥就已经很优秀了，最后一门考试未结束，一切都不能下定论。考试过程中，任何讨论都没有价值，不要分散注意。印象中，那些表现很沮丧或者很happy的同学最终结果都没太令人满意。保持冷静，正常发挥。 看什么政治看肖四，数学、专业课看错题，英语背作文。随便翻翻，不要太紧张。 心态并不是要考满分，你的对手是你自己。考进初试线，第一场战役你就胜利了，不是要考到完美，结果完美最重要。 贸大见！ 在贸大遇见你，是我今生最美的风景。","tags":[{"name":"考研","slug":"考研","permalink":"http://blog.feelyou.top/tags/考研/"}]},{"title":"API更新 图书信息查询ISBN2.0","date":"2019-11-27T12:41:38.000Z","path":"posts/isbn2.html","text":"ISBN图书查询 自2019年5月8日公布isbn查询接口1.0至今，该图书数据查询服务已被调用八万余次，查得图书11653本，感谢一直使用和关心这个接口的朋友们！ 目前网站域名将于2019年12月11日到期，qiaohaoforever.cn域名将停止服务，请目前还是使用此域名接口的朋友注意调整新的接口，如有不便之处请多包涵。 关于更新图书信息查询isbn2.0接口新增了部分开发者感兴趣的字段，图书简介、作者简介、目录、原文摘要、评论赞同数等，具体请见下方字段说明。针对外国书刊译者信息不统一的情况，这里采用图书摘要的字段显示作者、译者、出版社、出版时间、价格等。后期更新，字段以目前版本为主，尽量不改变现有字段含义，增加新的字段名。 架构调整在服务架构上也做了一些调整，1.0版本为单机服务，2.0版本采用两台服务器负载均衡的方式分担压力，缓存机制优化等。 关于爬虫根据日志可以看到，八万多次调用中也有明显的爬虫调用迹象，作为一名开发爱好者，我深刻的清楚大家没有办法忍住看到接口不爬的感情，为了服务于大家的热情，我并没有在反爬虫的方向做太苛刻的防守，但太过高频的爬虫容易触发豆瓣的反爬虫机制，导致接口无法获取最新的图书信息，所以，对于爬虫单位时间爬取频率做了部分限制🚫，望各位爬虫老哥记得设置一下爬取间隙，稍微sleep一下，温柔一点，哈哈哈😂 ISBN图书查询接口说明调用地址：http://book.feelyou.top/isbn/ISBN 请求方式：GET 返回类型：JSON 请求示例：http://book.feelyou.top/isbn/9787506380263 请求参数（Query） 名称 类型 是否必须 描述 ISBN STRING 必选 10-13位ISBN码 字段说明 首级标签 名称 类型 示例值 描述 create_time 2019-11-05 14:25:09 初次查询时间，统计使用，开发者可忽略 isbn string 9787506380263 图书isbn码 title string 人间失格 书名 abstract string 太宰治 / 杨伟 / 作家出版社 / 2015-8 / 25.00元 图书摘要（作者、译者、出版社、出版时间、价格等） book_intro string 收录《人间失格》《维庸之妻》《Good-bye》《灯笼》《满愿》《美男子与香烟》《皮肤与心》《蟋蟀》《樱桃》 图书简介 author_intro string 太宰治，“私小说”领域的天才。与川端康成、三岛由纪夫齐名，被视为日本战后文学的巅峰人物，后人称其为“无赖派大师”。 作者简介 catalog string 人间失格/001\\n维庸之妻/101\\nGood-bye/128\\n灯笼/167\\n满愿/174\\n美男子与香烟/177\\n······\\n(更多)” 目录。页面无目录时,字段为[] original_texts list [“一旦别人问起自己想要什么，那一刹那反倒什么都不想要了。怎么样都行，反正不可能有什么让我快乐的东西——这种想法陡然掠过我的脑海。 (查看原文)\\n\\n \\n\\n\\n\\n\\nmona其实在阴笑\\n9 回复\\n2012-02-24 14:52:00\\n\\n\\n —— 引自第14页”,”胆小鬼连幸福都会害怕，碰到棉花都会受伤，有时还会被幸福所伤。 (查看原文)\\n\\n \\n\\n\\n\\n\\nwheat\\n4 回复\\n2012-06-23 21:55:39\\n\\n\\n —— 引自第35页”] 原文摘录，无此项时为[],根据换行符区分内容 labels list [“太宰治”,”悲观”,”日本文学”,”【日】太宰治”,”失去为人的资格”,”日本”,”无赖派文学”,”文学”] 标签🏷️ cover_url string https://img1.doubanio.com/view/subject/l/public/s29118837.jpg 图书封面图片 url string https://book.douban.com/subject/26647769/ 该图书豆瓣页面 rating count int 25979 参与评分人数 rating rating_info string 暂无评分 暂无评分或评分人数不够等信息 rating star_count float 4 评分星🌟 rating value float 8.2 图书总评分 comments user_name string 小莉啊 豆瓣用户昵称 comments user_page string https://www.douban.com/people/lianhuaroad/ 豆瓣用户个人页 comments user_pic string https://img1.doubanio.com/icon/u47055426-37.jpg 豆瓣用户头像 comments vote string 483 评论支持数 comments rate int 50 单个豆瓣用户评分 comments time string 2016-09-27 评论发布时间 comments content string 太宰治唯恐一生过得不失格 评论内容 source string mongodb、redis、web 数据来源，统计使用，开发者可忽略 正常返回结果示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&#123; \"create_time\": \"2019-11-28 17:18:34\", \"isbn\": \"9787506380263\", \"title\": \"人间失格\", \"abstract\": \"太宰治 / 杨伟 / 作家出版社 / 2015-8 / 25.00元\", \"book_intro\": \"收录《人间失格》《维庸之妻》《Good-bye》《灯笼》《满愿》《美男子与香烟》《皮肤与心》《蟋蟀》《樱桃》\", \"author_intro\": \"太宰治，“私小说”领域的天才。与川端康成、三岛由纪夫齐名，被视为日本战后文学的巅峰人物，后人称其为“无赖派大师”。\", \"catalog\": \"人间失格/001\\n维庸之妻/101\\nGood-bye/128\\n灯笼/167\\n满愿/174\\n美男子与香烟/177\\n······\\n(更多)\", \"original_texts\": [ \"一旦别人问起自己想要什么，那一刹那反倒什么都不想要了。怎么样都行，反正不可能有什么让我快乐的东西——这种想法陡然掠过我的脑海。 (查看原文)\\n\\n \\n\\n\\n\\n\\nmona其实在阴笑\\n9 回复\\n2012-02-24 14:52:00\\n\\n\\n —— 引自第14页\", \"胆小鬼连幸福都会害怕，碰到棉花都会受伤，有时还会被幸福所伤。 (查看原文)\\n\\n \\n\\n\\n\\n\\nwheat\\n4 回复\\n2012-06-23 21:55:39\\n\\n\\n —— 引自第35页\" ], \"labels\": [ \"太宰治\", \"悲观\", \"日本文学\", \"【日】太宰治\", \"失去为人的资格\", \"日本\", \"无赖派文学\", \"文学\" ], \"cover_url\": \"https://img1.doubanio.com/view/subject/l/public/s29118837.jpg\", \"url\": \"https://book.douban.com/subject/26647769/\", \"rating\": &#123; \"value\": 8.2, \"count\": 26240, \"rating_info\": \"\", \"star_count\": 4 &#125;, \"comments\": [ &#123; \"user_name\": \"小莉啊\", \"user_page\": \"https://www.douban.com/people/lianhuaroad/\", \"user_pic\": \"https://img1.doubanio.com/icon/u47055426-37.jpg\", \"vote\": \"486\", \"rate\": \"50\", \"time\": \"2016-09-27\", \"content\": \"太宰治唯恐一生过得不失格\" &#125;, &#123; \"user_name\": \"3乐\", \"user_page\": \"https://www.douban.com/people/Smoldering/\", \"user_pic\": \"https://img3.doubanio.com/icon/u2394018-4.jpg\", \"vote\": \"320\", \"rate\": \"40\", \"time\": \"2016-01-29\", \"content\": \"人间失格这一篇读了很久，很难。不太了解作者所以也无法了解这篇里的不堪。后面的短篇很精彩，goodbye的戛然而止真是令人扼腕。要重读。\" &#125;, &#123; \"user_name\": \"小丑向月亮生气\", \"user_page\": \"https://www.douban.com/people/eluard_yazu/\", \"user_pic\": \"https://img9.doubanio.com/icon/u1079617-6.jpg\", \"vote\": \"157\", \"rate\": \"50\", \"time\": \"2016-05-21\", \"content\": \"皮肤和心&amp;蟋蟀比广受好评的维庸之妻好。真想看完goodbye呀\" &#125;, &#123; \"user_name\": \"柴犬妹妹\", \"user_page\": \"https://www.douban.com/people/rosvita/\", \"user_pic\": \"https://img3.doubanio.com/icon/u1471190-94.jpg\", \"vote\": \"148\", \"rate\": \"30\", \"time\": \"2016-05-08\", \"content\": \"“实用性的苦恼，仅凭吃饭就能一笔勾销的苦恼，或许才是最强烈的痛苦。”本书吧～真是～论一个富二代的自怨自哀。\" &#125;, &#123; \"user_name\": \"小圈\", \"user_page\": \"https://www.douban.com/people/lycle/\", \"user_pic\": \"https://img3.doubanio.com/icon/u1799314-1.jpg\", \"vote\": \"110\", \"rate\": \"50\", \"time\": \"2017-02-12\", \"content\": \"如果我露出了真身 可否被抱紧\" &#125;, &#123; \"user_name\": \"亞麻君\", \"user_page\": \"https://www.douban.com/people/gongyangfan/\", \"user_pic\": \"https://img3.doubanio.com/icon/u3180126-250.jpg\", \"vote\": \"71\", \"rate\": \"40\", \"time\": \"2017-07-22\", \"content\": \"太宰治最后自杀了还是好事，他真的不适合这个社会。文字处处揭示社会的阴暗却越是苍白无力，越是狡猾装腔作势之人越顺应社会。所以生而为人对不起。\" &#125;, &#123; \"user_name\": \"木昜先生\", \"user_page\": \"https://www.douban.com/people/69034301/\", \"user_pic\": \"https://img9.doubanio.com/icon/u69034301-6.jpg\", \"vote\": \"61\", \"rate\": \"40\", \"time\": \"2017-04-14\", \"content\": \"为什么一个一心作死的家伙还这么有女人缘？\" &#125;, &#123; \"user_name\": \"流浪の小圆头\", \"user_page\": \"https://www.douban.com/people/aaaaaaaaaaa/\", \"user_pic\": \"https://img3.doubanio.com/icon/u48329159-101.jpg\", \"vote\": \"52\", \"rate\": \"40\", \"time\": \"2017-04-01\", \"content\": \"我的双乳之间是泪水的溪谷。\" &#125;, &#123; \"user_name\": \"Neski.\", \"user_page\": \"https://www.douban.com/people/loveasondepp/\", \"user_pic\": \"https://img9.doubanio.com/icon/u4027330-56.jpg\", \"vote\": \"68\", \"rate\": \"30\", \"time\": \"2016-05-15\", \"content\": \"之前读过一遍人间失格，只记得我不太喜欢这个故事，总觉得男主有点.....怎么说...作？后来故事忘的一干二净，最近重读了这本收录别的短片的，依然不喜欢这个故事，太宰治的一生都像一个正在建立三观的中二少年，可是他却又对自己看的如此透彻，他就像那个一直在装睡的人，连他自己都不愿醒来。字里行间能感受到的是一种病态的抓狂，就像暴食症患者明明吃到吐明明知道并不那么美味却还在不断的往嘴里塞东西，这不是我们常说的，错的，就停下来这么简单\" &#125;, &#123; \"user_name\": \"筑舟岛\", \"user_page\": \"https://www.douban.com/people/60792379/\", \"user_pic\": \"https://img3.doubanio.com/icon/u60792379-23.jpg\", \"vote\": \"82\", \"rate\": \"40\", \"time\": \"2016-03-04\", \"content\": \"早就听到太宰治的大名。这本人间失格，却是一个中篇和短篇的合集。高尔基评价太宰治：一方面带着自身经历主人公的挣扎；另一方面坦然描述血的事实。确实很中肯。\\ngoodbye这篇，很有推理悬疑小说的感觉，然而未完成，让人好挂念。\\n这本书的流行，让我有些纳闷。此书常常以第一人称写惨淡的生活，然而不大让读者感觉其惨淡，这是它的高明处。如果说，这本我们看到的译本，就是太宰治的水准代表的话，他是名实不符的。\" &#125; ], \"source\": \"web\"&#125; 关于未来一定有很多朋友实现了自己的小程序，可以分享在这里，大家体验体验，学习探讨一下～ 对了，腾讯云也不让我继续学生认证了，难过，自有服务器的朋友可以和我联系，让服务稳定持续进行下去！ 微信公众号：正版乔","tags":[{"name":"api","slug":"api","permalink":"http://blog.feelyou.top/tags/api/"},{"name":"nodejs","slug":"nodejs","permalink":"http://blog.feelyou.top/tags/nodejs/"},{"name":"python","slug":"python","permalink":"http://blog.feelyou.top/tags/python/"}]},{"title":"树莓派更新失败","date":"2019-07-27T02:43:40.000Z","path":"posts/14337281.html","text":"最近日常给树莓派apt-get upgrade ，然鹅，一直报错，导致更新下载都无法进行。。。 aufs-dkms 软件包 post-installation 脚本 子进程返回错误状态 10 找了一圈，找到了下面的解决办法👇12345678910111213# 现将info文件夹更名$ sudo mv /var/lib/dpkg/info /var/lib/dpkg/info_old # 再新建一个新的info文件夹$ sudo mkdir /var/lib/dpkg/info # 重新update、upgrade$ sudo apt-get update &amp; apt-get -f install # 将更新的info内容和原始info文件合并在以前，恢复info文件夹位置，删除过渡文件夹$ sudo mv /var/lib/dpkg/info/* /var/lib/dpkg/info_old $ sudo rm -rf /var/lib/dpkg/info $ sudo mv /var/lib/dpkg/info_old /var/lib/dpkg/info","tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://blog.feelyou.top/tags/树莓派/"}]},{"title":"396复习","date":"2019-06-05T04:04:18.000Z","path":"posts/832775011.html","text":"作者：唐亦六安 链接：https://www.zhihu.com/question/23131279/answer/681657986 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 19年考研上岸，其中经济类联考124分，不算太高，不过这个分数于我而言还算满意，去年搜集经济类联考经验贴时受到许多学长学姐帮助，今天来分享一下自己备考经济类联考的一些经验，希望对学弟学妹有所帮助。 关于数学 数学部分全程我用了三本资料，跨考教育的《核心笔记》、《60天攻克800题》，以及朱杰的《题源深析经典1000题》。 img 核心笔记和800题必买，尽管它年代很久远，但考点涵盖全面，里面很多题目来源于数学三真题，高等数学课后练习题习题、学生高频易错题等，《核心笔记》每一章前面的大纲总结公式非常详细，完全可以把核心笔记当作数学教材认真研读写题，《800题》上有很多题目与核心笔记重合，总难度比核心笔记难一点，二者互补可查漏补缺，可以说，把这两本上面每个题目弄懂，数学部分没问题。而朱杰那本《题源探析1000题》我是暑假买来刷题的，当时一天20个小题然后错题订正，里面有很多超纲题，难度比跨考教育那两本都大，当时做完一大堆红叉叉，不过里面题型很丰富，对于同一个考点，核心笔记上没看懂的话我会借助1000题找到类似考题进行检验和知识迁移，九月开学前学有余力的同学可以买来刷刷题。九月份后个人认为还是以核心笔记和800题为主。 网课方面我是全程跟着方浩老师。 高数：https://b23.tv/av26516451/p1 线代：https://b23.tv/av21075904/p1 概率论：https://b23.tv/av14785532/p1 听浩哥的数学三网课，即396考纲范围内的基础班和强化班（之前也有听过汤家凤老师、张宇老师以及专门做396数学辅导的刘纬宇老师、朱杰老师的网课，最后毅然选择跟着萌萌哒的浩哥走~）在我看来，经济类联考数学就是要快准狠。浩哥的一些数学技巧可以帮忙大大缩短计算时间，应试性很强。我印象非常深的是线性代数部分听了浩哥课及他总结的考点公式后，看《800题》直接用他教的方法秒杀选择题，30秒一个，30秒一个，简直不要太爽。（PS，数学错题本可以去淘宝买花20块钱买一坨500张A4纸，写题时将纸对折，从左往右从上往下依次写，方便查阅计算步骤和订正，十分方便。） img 时间方面，3月-暑假前核心笔记例题和课后习题一道一道过关，整理错题集。暑假强化阶段核心笔记二刷+1000题，九月-10月核心笔记三刷+800题（重点就是要把核心笔记上每一道题都吃透，曾经我听过一位学姐说，一本资料至少得刷三遍，在我实践后确实感觉每刷一遍都有不同体会，一般对于错题，我先是看答案，接着盖住看自己能不能把步骤写出来，然后第二天再自己独立解题，若还不会再把答案思路记下，模仿解题思路，隔几天再写，直到能够独立完整写下解题步骤为止）。11月后做套卷，并将核心笔记错题相关考点反复做，看错题本。 关于逻辑 逻辑我用了两本，暑假前一直用的老吕逻辑，暑假后到初试前用的周建武历年真题题库（那本600题我也买了，不过只做了前六套，后面没有时间写了）。 img 老吕老师有一个《三天学会形式逻辑》课程，我在大三上本科逻辑课时空余时间有听过他的课，当时感觉他把形式逻辑讲的非常通俗易懂，可以帮助快速入门。市面上还有一本赵鑫全老师的《逻辑精点》也很火（我没有用过，就不做评价了）两本择其一就行，基本上自习室里逻辑书就老吕和鑫全两大类（作文书王诚老师那两本黄皮书几乎人人一本…），不过暑假开始个人觉得还是以真题为主，也就是周建武老师那本《逻辑历年真题分类精解》（19年是红皮的，貌似20年变成绿皮了），这本书排版很好看，题目很全，算是经济类联考考生的一本权威书，当碰到逻辑争议题时，也是以周书为主。（吐槽一句，这些年积攒的逻辑争议题大概有十多个，王诚老师和周建武老师两本逻辑真题书对答案有不一的不必感到惊讶…） 网课部分，形式逻辑我个人比较推荐王洋老师，王洋老师课程应试性很强，把“除非…否则…”直接符号化U等小技巧很方便）论证逻辑部分我跟的王诚老师和孙勇老师。 对于孙勇老师，当时听的这个课程https://b23.tv/av20919936/p1孙勇老师的这个论证部分对我启蒙很大。削弱、假设、支持等题型讲的非常透彻。其他的老师比如饶思中老师、薛睿老师、老吕老师、赵鑫全老师、胡海滨老师课程都可以试听一下，选择一位自己喜欢的老师跟着就行。 这里瞎逼逼一句，396逻辑与199逻辑还是有区别的，396逻辑更注重论证逻辑其次是形式逻辑（经济类联考有原题，这里的原题包括199管理类原题，也有396经济类联考之前考过的）。而199逻辑包括形式逻辑、论证逻辑和综合逻辑。做到最后你会发现，论证逻辑比形式逻辑简单太多。。形式逻辑推来推去真的挺耗时的。。 关于作文 作文部分包括一篇论证有效性写作，一篇论说文写作。我买的是王诚老师的作文素材（我们那一桌2个考经济类，1个考管理类，所以作文书方面许多都换着看），其次王帅老师的写作基本功，这本书也是后期偶然看到的，里面时政素材很多且语句精简，素材在我看来更贴合经济类联考要求。 img 作文部分包括论证有效性写作和论说文写作。先来说说论证有效性写作（论证有效性写作199和396考题差不多，可以把历年199管理类真题来练手。）它主要是给你一篇漏洞百出的文章让你来找漏洞然后批判。取题目很有规律，就是质疑。先找到那篇漏洞百出的文章的核心观点，比如我们读出它核心观点是“不必干预自然”，那么我们写文章取题目就是，“不必干预自然吗？”（真的搞不懂为什么市面上的作文书取题目都要花一章节来说…直接找核心观点然后加个“吗”或“了吗”就做了标题了多方便…）。而正文部分一般分为六大段。第一段点题，中间四段对应漏洞文章的四段，每一段挑一个漏洞指出然后说理由，最后一段总结。论证有效性文章标题、首尾段都是模板，而历年的逻辑漏洞考来考去就那么几个，针对性总结，难度不大。 论说文部分相比于论证有效性而言难度大一些，因为其主题广泛，写法多样，重点揣摩角度也不一，一开始我接触论说文时确实有点无从下笔。但在后期真题练手总结后，感觉论说文也没有想象的那么可怕。我当时是把历年经济类联考真题范文全部抄了一遍，分析其中的结构思路，慢慢形成了写作框架，【这里推荐几个公众号：今日话题，专硕王诚，缓缓说。多看看上面的文章对写作有很大提升】经济类联考论说文主题主要是社会品质类及评析社会社会现象或社会热点问题，而不会考企业中的一些事(这个管理类联考比较喜欢考)。论说文无法做模板，因为它真的变化多端，但它还是有套路可寻的，总结几种常用思路框架，然后分析题型直接带入，比如第一段点题（同时立观点），接着分析原因，结合对比，类比等手法，最后由点及面上升至社会层面升华主题等等。就感觉和打辩论一样，有理有据写下来思路非常通畅。 关于真题集和模拟卷 img 真题部分我用的王诚老师那本396历年真题全解，里面作文范文好好看可以学到很多东西。而模拟题部分，质量比较好的是王诚八套卷(江湖人称396劝退卷……)，还有中公后期也会出396的模拟卷。我当时是把市面上所有的396模拟卷都买来了，用作模拟。（不要把模拟卷分板块写，一定要掐表按考试模式来模拟!!） 在我看来396考的就是速度和心态，后期模拟真的很重要，模拟可以提高自己的”题感”，即一上考场，立马就能开启考场模式，进入备战状态。这也是我去年备考时从一位高分学姐上学到的，尤其到了最后11，12月份，后期模拟很重要。 以上是我的一些经验分享，祝各位学弟学妹成功考取理想学校","tags":[{"name":"考研","slug":"考研","permalink":"http://blog.feelyou.top/tags/考研/"}]},{"title":"豆瓣读书isbn 查询","date":"2019-05-08T14:47:00.000Z","path":"posts/1404226277.html","text":"最近学习微信小程序，做一个类似“书库”的小demo，大致流程使用摄像头获取书本后面的isbn，通过豆瓣读书API得到书本介绍、豆瓣评分、图书评论等信息，然鹅https://api.douban.com/v2/book/isbn/:name停服了！ 在网上找了一圈，有意思了，ISBN——国际标准书号（International Standard Book Number)这种理论上应该公开的信息却没有相关资源！ 号称中国ISBN中心 - 中国版本图书馆，这个网站翻了一遍也没有能够查isbn的地方，不可思议！ 然后，鹅厂是这样的： 福厂是这样的: 评论看起来也不太靠谱！图书库信息缺失严重，接口调用失败，调用次数计费不清。。。 豆瓣图书API不在的日子，想ta!豆瓣提供图书查询API的时候，一个接口就可以查询到书本基本信息、用户评分、用户评论等，豆瓣评分很大程度上描述了一本书受欢迎的程度。但是，近年大家的代码学习也有很多直接调用豆瓣API，我也是，基于豆瓣数据出现了很多商业app，最近比较火的多抓鱼图书评分等数据的来源应该是豆瓣。所以，豆瓣可能也是基于这些原因关闭了图书isbn查询接口。豆瓣关闭图书查询接口后，各个与数据相关的厂商也趁机出来圈钱，质量良莠不齐，豆瓣图书API不在的日子，想ta! 自己造！ISBN图书查询调用地址：https://isbn.qiaohaoforever.cn/ISBN 请求方式：GET 返回类型：JSON 请求示例：https://isbn.qiaohaoforever.cn/9787506380263 请求参数（Query） 名称 类型 是否必须 描述 ISBN STRING 必选 10-13位ISBN码 返回参数 首级标签 名称 类型 示例值 描述 create_time 1557302752213 初次查询时间戳 comments rate string 5 单个豆瓣用户评分 comments user string 小莉啊 豆瓣用户昵称 comments img string https://img1.doubanio.com/icon/u47055426-37.jpg 豆瓣用户头像 comments date string 2016-09-27 评论发布时间 comments content string 太宰治唯恐一生过得不失格 评论内容 tags title string 日本文学 标签🏷️ author string 太宰治 图书作者 publisher string 作家出版社 图书出版社 price string 25.00元 图书价格 isbn string 9787506380263 图书isbn编号 image string https://img1.doubanio.com/view/subject/l/public/s29118837.jpg 图书封面图片 rate float 8.2 图书总评分 alt string https://book.douban.com/subject/26647769/ 该图书豆瓣页面 title string 人间失格 书名 summary string \\n 收录《人间失格》《维庸之妻》《Good-bye》《灯笼》《满愿》《美男子与香烟》《皮肤与心》《蟋蟀》《樱桃》 图书简介 正常返回结果示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&#123; \"create_time\": 1557302752213, \"comments\": [ &#123; \"rate\": \"5\", \"user\": \"小莉啊\", \"img\": \"https://img1.doubanio.com/icon/u47055426-37.jpg\", \"date\": \"2016-09-27\", \"content\": \"太宰治唯恐一生过得不失格\" &#125;, &#123; \"rate\": \"4\", \"user\": \"3乐\", \"img\": \"https://img3.doubanio.com/icon/u2394018-4.jpg\", \"date\": \"2016-01-29\", \"content\": \"人间失格这一篇读了很久，很难。不太了解作者所以也无法了解这篇里的不堪。后面的短篇很精彩，goodbye的戛然而止真是令人扼腕。要重读。\" &#125;, &#123; \"rate\": \"5\", \"user\": \"小丑向月亮生气\", \"img\": \"https://img3.doubanio.com/icon/u1079617-6.jpg\", \"date\": \"2016-05-21\", \"content\": \"皮肤和心&amp;蟋蟀比广受好评的维庸之妻好。真想看完goodbye呀\" &#125;, &#123; \"rate\": \"3\", \"user\": \"柴犬妹妹\", \"img\": \"https://img3.doubanio.com/icon/u1471190-93.jpg\", \"date\": \"2016-05-08\", \"content\": \"“实用性的苦恼，仅凭吃饭就能一笔勾销的苦恼，或许才是最强烈的痛苦。”本书吧～真是～论一个富二代的自怨自哀。\" &#125;, &#123; \"rate\": \"5\", \"user\": \"小圈\", \"img\": \"https://img3.doubanio.com/icon/u1799314-1.jpg\", \"date\": \"2017-02-12\", \"content\": \"如果我露出了真身 可否被抱紧\" &#125;, &#123; \"rate\": \"4\", \"user\": \"亞麻君\", \"img\": \"https://img3.doubanio.com/icon/u3180126-250.jpg\", \"date\": \"2017-07-22\", \"content\": \"太宰治最后自杀了还是好事，他真的不适合这个社会。文字处处揭示社会的阴暗却越是苍白无力，越是狡猾装腔作势之人越顺应社会。所以生而为人对不起。\" &#125; ], \"tags\": [ &#123; \"title\": \"太宰治\" &#125;, &#123; \"title\": \"悲观\" &#125;, &#123; \"title\": \"日本文学\" &#125;, &#123; \"title\": \"【日】太宰治\" &#125;, &#123; \"title\": \"失去为人的资格\" &#125;, &#123; \"title\": \"日本\" &#125;, &#123; \"title\": \"文学\" &#125;, &#123; \"title\": \"无赖派文学\" &#125; ], \"author\": \"太宰治\", \"publisher\": \" 作家出版社\", \"price\": \" 25.00元\", \"isbn\": \"9787506380263\", \"image\": \"https://img1.doubanio.com/view/subject/l/public/s29118837.jpg\", \"rate\": 8.2, \"alt\": \"https://book.douban.com/subject/26647769/\", \"title\": \"人间失格\", \"summary\": \"\\n 收录《人间失格》《维庸之妻》《Good-bye》《灯笼》《满愿》《美男子与香烟》《皮肤与心》《蟋蟀》《樱桃》\"&#125;","tags":[{"name":"api","slug":"api","permalink":"http://blog.feelyou.top/tags/api/"},{"name":"nodejs","slug":"nodejs","permalink":"http://blog.feelyou.top/tags/nodejs/"},{"name":"python","slug":"python","permalink":"http://blog.feelyou.top/tags/python/"}]},{"title":"【词云】听故事的故事人","date":"2019-01-16T15:49:20.000Z","path":"posts/1861734117.html","text":"123456789101112131415161718192021222324252627282930313233import reimport timeimport sqlite3import jiebaimport collections # 词频统计库from pyecharts import Barfrom pyecharts import WordCloudfrom pyecharts import Lineconn = sqlite3.connect('./music.db')c = conn.cursor()stopwords_list = ['吗', '的','啊',' ','是', '吧','了','在','就','有','呀','这', '很','要','…','给',]word_list = []# 文本预处理pattern = re.compile(u'\\t|\\n|\\.|-|:|;|\\)|\\(|\\?|\\，|\\。|\\！|\\？|\"|\\]|\\[|\\、|\\”|\\“|\\~|\\～|\\、') # 定义正则表达式匹配模式print(\"Opened database successfully\")cursor = c.execute(\"SELECT music_name, comment_id, user_id, user_name, avatar_url, comment_time, liked_count, comment from music2057578222\")for row in cursor: print('user_name:&#123;&#125;'.format(row[3])) print('comment_time:&#123;&#125;'.format(row[5])) print('liked_count:&#123;&#125;'.format(row[6])) print('comment:&#123;&#125;\\n'.format(row[7])) seg_list = [i for i in jieba.cut(re.sub(pattern, '', row[7]))]# 将符合模式的字符去除 print(seg_list) for seg in seg_list: if seg not in stopwords_list: word_list.append(seg) else: print(seg)print(\"Operation done successfully\")conn.close() 1234# 词频统计word_counts = collections.Counter(word_list) # 对分词做词频统计word_counts_top100 = word_counts.most_common(100) # 获取前10最高频的词print (word_counts_top100) # 输出检查 12345myWordCloud = WordCloud(\"评论词云\",width=1000, height=620)words = list(word_counts_top100.keys())value = list(word_counts_top100.values())myWordCloud.add(\"\",words,value,shape=\"circle\",word_size_range=[20,100])myWordCloud.render() 123comment_time.append(time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(row[5]/1000)))comment_time_day.append(time.strftime(\"%Y-%m-%d\", time.localtime(row[5]/1000)))comment_time_hour.append(time.strftime(\"%H\", time.localtime(row[5]/1000))) 12345678# 词频统计day_counts = collections.Counter(comment_time_day) # 对分词做词频统计day_counts = sorted(day_counts.items())day_countsline = Line(\"评论日期\")line.add(\"\", [i[0] for i in day_counts], [i[1] for i in day_counts],is_label_show=True, mark_point=[\"average\",\"max\"])line.render('line.html')line 1234567891011121314# 词频统计hour_counts = collections.Counter(comment_time_hour) # 对分词做词频统计hour_counts = sorted(hour_counts.items())hour_countsbar = Bar(\"评论时间\")bar.add(\"bar\", [i[0] for i in hour_counts], [i[1] for i in hour_counts],is_label_show=True)line = Line()line.add(\"line\",[i[0] for i in hour_counts], [i[1] for i in hour_counts])overlap = Overlap()overlap.add(bar)overlap.add(line)overlapoverlap.render('bar.html')","tags":[]},{"title":"【学习整理】hadoop大数据解决方案","date":"2019-01-14T12:43:52.000Z","path":"posts/2445394680.html","text":"hadoop大数据解决方案 test 9f41905cad2d30e5f82859105a99c5c1.jpeg Hadoop简介Hadoop特点 Java编写 跨计算机集群的分布式存储和计算的环境 可以上千台机器扩展，每个机器都可以提供本地计算和存储 Hadoop架构 1d66ee7db3bc4383619d0e69a61f1ab4.jpeg Hadoop主要有两个层次，即： 加工/计算层(MapReduce) 存储层(Hadoop分布式文件系统) Hadoop的框架还包括以下两个模块： Hadoop通用：这是Java库和其他Hadoop组件所需的实用工具。 Hadoop YARN ：这是作业调度和集群资源管理的框架。 Hadoop安装 HDFS分布式文件储存系统 d11ec7d9f4a03f3f37d13873810f9231.jpeg hdfs 特点 它适用于在分布式存储和处理。 Hadoop提供的命令接口与HDFS进行交互。 名称节点和数据节点能够检查集群的状态。 流式访问文件系统数据。 HDFS提供了文件的权限和验证。 名称节点 - Namenode（主服务器） 管理文件系统命名空间。 规范客户端对文件的访问。 它也执行文件系统操作，如重命名，关闭和打开的文件和目录 数据节点 - Datanode数据储存 数据节点上的文件系统执行的读写操作，根据客户的请求。 根据名称节点的指令执行操作，如块的创建，删除和复制。 块 - Rack存储在HDFS文件系统中的文件将被划分为一个或多个段和/或存储在个人数据的节点。这些文件段被称为块。换句话说，数据的HDFS可以读取或写入的最小量被称为一个块。 HDFS的目标 故障检测和恢复：由于HDFS包括大量的普通硬件，部件故障频繁。因此HDFS应该具有快速和自动故障检测和恢复机制。 巨大的数据集：HDFS有数百个集群节点来管理其庞大的数据集的应用程序。 数据硬件：请求的任务，当计算发生不久的数据可以高效地完成。涉及巨大的数据集特别是它减少了网络通信量，并增加了吞吐量。 Hadoop HDFS入门HDFS集群主要由 NameNode 管理文件系统 Metadata 和 DataNodes 存储的实际数据。 NameNode: NameNode可以被认为是系统的主站。它维护所有系统中存在的文件和目录的文件系统树和元数据。两个文件：“命名空间映像“和”编辑日志“是用来存储元数据信息。Namenode 有所有包含数据块为一个给定的文件中的数据节点的知识，但是不存储块的位置持续。从数据节点在系统每次启动时信息重构一次。 DataNode : DataNodes作为从机，每台机器位于一个集群中，并提供实际的存储. 它负责为客户读写请求服务。 HDFS读操作 cae7454447bfe5e265d456d6cc96e5ef.png HDFS写操作 b3801f95eb955d974fca8c0638559c77.png 使用命令行界面访问HDFS 从本地文件系统复制文件到 HDFS: hdfs dfs -copyFromLocal temp.txt / 列出一个目录下存在的文件 -ls: hdfs dfs -ls / 从 HDFS 拷贝到本地文件系统: hdfs dfs -copyToLocal /temp.txt 创建新的目录: hdfs dfs -mkdir /mydirectory Hadoop HDFS操作将Hadoop应用路径配置在.bashrc $HADOOP_HOME/bin/hadoop hdfs文件列表：hadoop fs -ls &lt;args&gt; 将数据插入到HDFS： 创建目录：hadoop fs -mkdir /user/input 传输本地文件至Hadoop文件系统：hadoop fs -put /home/file.txt /user/input ls命令验证文件:hadoop fs -ls /user/input 从HDFS中检索数据 cat命令来查看HDFS数据:hadoop fs -cat /user/output/outfile 从HDFS得到文件使用get命令在本地文件系统：hadoop fs -get /user/output/ /home/hadoop_tp/ Hadoop fs命令参考查看Hadoop命令：hadoop fs -help 02148d22eceb03aa6b31cb1bbf14bb75.png daf97a2dbafe8a65655415ba467642a6.png a345d30e93ffa5cc0f16658ad742a3ea.png Hadoop MapReduce e1fe9a4236dffb67441e3d4fed016b80.png MapReduce简介MapReduce是基于Java的分布式计算，包含了两项重要任务，即Map 和 Reduce。Map采用了一组数据，并将其转换成另一组数据，其中，各个元件被分解成元组(键/值对)。其次，减少任务，这需要从Map 作为输入并组合那些数据元组成的一组小的元组输出。MapReduce主要优点是，它很容易大规模数据处理在多个计算节点。MapReduce模型中，数据处理的原语被称为映射器和减速器。但是编写MapReduce形式的应用，扩展应用程序运行在几百，几千，甚至几万机集群中的仅仅是一个配置的更改。 算法MapReduce计划分三个阶段执行，即映射阶段，shuffle阶段，并减少阶段： 映射阶段：映射或映射器的工作是处理输入数据。一般输入数据是在文件或目录的形式，并且被存储在Hadoop的文件系统（HDFS）。输入文件被传递到由线映射器功能线路。映射器处理该数据，并创建数据的若干小块。 减少阶段：这个阶段是：Shuffle阶段和Reduce阶段的组合。减速器的工作是处理该来自映射器中的数据。处理之后，它产生一组新的输出，这将被存储在HDFS。 在一个MapReduce工作，Hadoop的发送Map和Reduce任务到集群的相应服务器。 框架管理数据传递例如发出任务的所有节点之间的集群周围的详细信息，验证任务完成，和复制数据。 大部分的计算发生在与在本地磁盘上，可以减少网络通信量数据的节点。 给定的任务完成后，将群集收集并减少了数据，以形成一个合适的结果，并且将其发送回Hadoop服务器。 1eb00bebcbf022bceb570b5abcd58495.jpeg 术语： PayLoad - 应用程序实现映射和减少功能，形成工作的核心 Mapper - 映射器的输入键/值对映射到一组中间键/值对 NamedNode - 节点管理Hadoop分布式文件系统（HDFS） DataNode - 节点数据呈现在任何处理发生之前。 MasterNode - 节点所在JobTracker运行并接受来自客户端作业请求。 SlaveNode - 节点所在Map和Reduce程序运行。 JobTracker - 调度作业并跟踪作业分配给任务跟踪器。 Task Tracker - 跟踪任务和报告状态的JobTracker。 Job -程序在整个数据集映射器和减速的执行。 Task - 一个映射程序的执行或对数据的一个片段的减速器。 Task Attempt - 一种尝试的特定实例在SlaveNode执行任务。 880897b4d04086e0db68dea8359dc8c7.png Hadoop Streaming eb007a9894797479e872a968e525fa42.png Hadoop数据流是Hadoop自带发行的实用程序。该程序允许创建和运行Map/Reduce任务的任何可执行文件或脚本映射器和/或减速器。任何工作在Hadoop中必须有两个阶段：映射器和减速器。映射阶段代码 mapper.py12345678910111213!/usr/bin/pythonimport sys# Input takes from standard input # Remove whitespace either side # Break the line into words # Iterate the words list # Write the results to standard outputfor myline in sys.stdin: myline = myline.strip() words = myline.split() for myword in words: print &apos;%s\\t%s&apos; % (myword, 1) 减速器阶段代码 reducer.py12345678910111213141516171819202122232425262728#!/usr/bin/python# Input takes from standard input # Remove whitespace either side # Split the input we got from mapper.py word# Convert count variable to integer # Count was not a number, so silently ignore this line continue# Write result to standard output # Do not forget to output the last word if needed! from operator import itemgetter import sys current_word = &quot;&quot;current_count = 0 word = &quot;&quot; for myline in sys.stdin: myline = myline.strip() count = myline.split(&apos;\\t&apos;, 1) try: count = int(count) except ValueError: if current_word == word: current_count += count else: if current_word: print &apos;%s\\t%s&apos; % (current_word, current_count) current_count = count current_word = word if current_word == word: print &apos;%s\\t%s&apos; % (current_word, current_count) wordCount程序的执行12345$ $HADOOP_HOME/bin/hadoop jar contrib/streaming/hadoop-streaming-1.2.1.jar \\ -input input_dirs \\ -output output_dir \\ -mapper &lt;path/mapper.py \\ -reducer &lt;path/reducer.py 数据流工作原理当指定映射器的脚本，每个映射任务将启动脚本作为一个单独的进程时映射器初始化。作为mapper任务运行时，输入转换成行给进程的标准输入（STDIN）。在此期间，映射器收集从该方法的标准输出（stdout）面向行输出和每一行转换为键/值对，其被收集作为映射器的输出。缺省情况下，一行到第一个制表符的前缀是键和行（不包括制表符）的其余部分为值。如果在该行没有任何制表符，则整行键和值被视为null。然而，这可以被定制，每次需要1个。当指定减速器脚本，每个减速器任务将启动脚本作为一个单独的进程，然后减速初始化。减速器任务运行时将其转换其输入键/值对，进入行并将该行进程的标准输入（STDIN）。在此期间，在减速机收集来自该过程的标准输出（stdout）的面向行的输出，每行转换成一个密钥/值对，其被收集作为减速机的输出。缺省情况下，一行到第一个制表符的前缀是键，（不包括制表符）的其余部分的值为行。然而，这可以被定制为每次具体要求。 06438f538e3d560eed19e525f9674d84.png Hadoop多节点集群Hadoop 生态系统组件 0f4a11c57b17f6395df1f323fdaa8e61.png Sqoop连接器:外部存储系统之间的数据传输 0f08c55ca876f254561dfd92ab467b71.png Flume 用于移动大规模批量流数据到 HDFS 系统 6370193749b13377c06c4739b184a041.png Pig 41109bd9bdb4a011801ade1a2d9e1a0f.jpeg Hive:基于Hadoop的Map-Reduce 框架之上的数据仓库解决方案 cc84411feaeca66cafd221b476406105.jpeg","tags":[]},{"title":"【数据库】听故事的故事人","date":"2019-01-13T15:30:38.000Z","path":"posts/2329761363.html","text":"123456789101112-- 注：语句为python执行语句-- 创建菜单数据库CREATE TABLE music_dic (music_id real, music_name text, time text);-- 菜单信息，有则更新，无则插入REPLACE INTO music_dic VALUES(?,?,?);-- 新建评论数据库CREATE TABLE IF NOT EXISTS music + str(music_id) + (music_name text, comment_id real ,user_id text,user_name text,avatar_url text,comment_time real,liked_count real,comment text);-- 插入爬虫数据INSERT INTO music\"+str(music_id)+\" VALUES(?,?,?,?,?,?,?,?);","tags":[]},{"title":"SQL行列乾坤大挪移","date":"2019-01-07T15:21:00.000Z","path":"posts/3671769839.html","text":"“生活总是这样，有时候，你需要一个苹果，但别人却给了你一个梨。” 今天dalao邮件里需要添加一张每月累计长长的图，可是，拿到手上的SQL导出数据不符合我最爱的pyecharts的数据输入格式，头大。 获得到的数据 日期 种类 数量 9012-01-01 香蕉 10 9012-01-01 苹果 99 9012-01-01 梨 9 9012-01-02 香蕉 100 9012-01-02 苹果 999 9012-01-02 梨 99 pyecharts想要的数据 日期 香蕉 苹果 梨 9012-01-01 10 99 9 9012-01-02 100 999 99 想到两个方案：方案一，python处理数据，修正为所需数据格式；方案二，修改SQL代码，直接输出指定格式。 其实以前有遇到过类似的问题，但总是习惯使用方案一来处理类似问题，稍微思考了一下，方案二居然一时半会想一个简单实现的好办法，，，难受。经过一番学习研究，获取到了“SQL行列乾坤大挪移”的精髓。123456789SELECT day AS \"日期\", SUM(IF(product=\"香蕉\", nums, 0)) AS \"香蕉\", SUM(IF(product=\"苹果\", nums, 0)) AS \"苹果\", SUM(IF(product=\"梨\", nums, 0)) AS \"梨\"FROM 一张待拯救的表GROUP BY dayORDER BY day; 当当当，行变成了列，这样就可以愉快的玩耍了，结合pyecharts画出dalao想要的款了，收工！","tags":[{"name":"数据库","slug":"数据库","permalink":"http://blog.feelyou.top/tags/数据库/"}]},{"title":"【leetcode】9.回文数","date":"2018-12-06T06:43:00.000Z","path":"posts/leetcode9.html","text":"判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121输出: true 示例 2: 输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 python1234567891011121314class Solution: def isPalindrome(self, x): &quot;&quot;&quot; :type x: int :rtype: bool &quot;&quot;&quot; if x &lt; 0: return False else: x = list(str(x)) for i in range(int(len(x)/2)): if x[i] != x[-(i+1)]: return False return True TODO进阶:你能不将整数转为字符串来解决这个问题吗？ PS:python3取商为float类型","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://blog.feelyou.top/tags/leetcode/"}]},{"title":"【leetcode】7.整数反转","date":"2018-12-05T03:04:00.000Z","path":"posts/leetcode7.html","text":"给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123输出: 321 示例 2: 输入: -123输出: -321 示例 3: 输入: 120输出: 21 注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−$2^{31}$, $2^{31}$, − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 python123456789101112131415class Solution(object): def reverse(self, x): &quot;&quot;&quot; :type x: int :rtype: int &quot;&quot;&quot; x = list(str(x)) if x[0] == &apos;-&apos;: x = (-1)*int(&apos;&apos;.join(x[-1:-len(x):-1])) else: x = int(&apos;&apos;.join(x[::-1])) if x&gt;= (-1)*(2**31) and x&lt;=2**31: return x else: return 0 参考资料： python list 倒序排列 python 次方 markdown 次方输入","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://blog.feelyou.top/tags/leetcode/"}]},{"title":"时序数据库InfluxDB","date":"2018-12-04T11:18:00.000Z","path":"posts/424938270.html","text":"在系统服务部署过后，线上运行服务的稳定性是系统好坏的重要体现，监控系统状态至关重要，经过调研了解，时序数据库influxDB在此方面表现优异。 influxDB介绍 时间序列数据是以时间字段为每行数据的标示，比如股票市场的价格，环境中的温度，主机的CPU使用率等。但是又有什么数据是不包含timestamp的呢？几乎所有的数据都可以打上一个timestamp字段。时间序列数据更重要的一个属性是如何去查询它。在查询的时候，对于时间序列我们总是会带上一个时间范围去过滤数据。同时查询的结果里也总是会包含timestamp字段。InfluxDB 是一个开源分布式时序、事件和指标数据库。使用 Go 语言编写，无需外部依赖。其设计目标是实现分布式和水平伸缩扩展。它有三大特性： Time Series （时间序列）：你可以使用与时间有关的相关函数（如最大，最小，求和等） Metrics（度量）：你可以实时对大量数据进行计算 Eevents（事件）：它支持任意的事件数据特点： schemaless(无结构)，可以是任意数量的列 min, max, sum, count, mean, median 一系列函数，方便统计 Native HTTP API, 内置http支持，使用http读写 Powerful Query Language 类似sql 操作介绍远程连接1influx -host xx.xx.xx.xx -port xxxx(默认8086) -username xx -password xx -database xx 创建及使用数据库123create database &quot;test&quot;; --创建数据库show databases; --查看数据库use test; --选取数据库 增删改查1234567891011121314151617181920212223242526272829SHOW MEASUREMENTS --查询当前数据库中含有的表SHOW FIELD KEYS --查看当前数据库所有表的字段SHOW series from pay --查看key数据SHOW TAG KEYS FROM &quot;pay&quot; --查看key中tag key值SHOW TAG VALUES FROM &quot;pay&quot; WITH KEY = &quot;merId&quot; --查看key中tag 指定key值对应的值SHOW TAG VALUES FROM cpu WITH KEY IN (&quot;region&quot;, &quot;host&quot;) WHERE service = &apos;redis&apos;DROP SERIES FROM &lt;measurement_name[,measurement_name]&gt; WHERE &lt;tag_key&gt;=&apos;&lt;tag_value&gt;&apos; --删除keySHOW CONTINUOUS QUERIES --查看连续执行命令SHOW QUERIES --查看最后执行命令KILL QUERY &lt;qid&gt; --结束命令SHOW RETENTION POLICIES ON mydb --查看保留数据查询数据SELECT * FROM /.*/ LIMIT 1 --查询当前数据库下所有表的第一行记录select * from pay order by time desc limit 2select * from db_name.&quot;POLICIES name&quot;.measurement_name --指定查询数据库下数据保留中的表数据 POLICIES name数据保留删除数据delete from &quot;query&quot; --删除表所有数据，则表就不存在了drop MEASUREMENT &quot;query&quot; --删除表（注意会把数据保留删除使用delete不会）DELETE FROM cpuDELETE FROM cpu WHERE time &lt; &apos;2000-01-01T00:00:00Z&apos;DELETE WHERE time &lt; &apos;2000-01-01T00:00:00Z&apos;DROP DATABASE “testDB” --删除数据库DROP RETENTION POLICY &quot;dbbak&quot; ON mydb --删除保留数据为dbbak数据DROP SERIES from pay where tag_key=&apos;&apos; --删除key中的tagSHOW SHARDS --查看数据存储文件DROP SHARD 1SHOW SHARD GROUPSSHOW SUBSCRIPTIONS 6、数据保留命令 查看保留期 SHOW RETENTION POLICIES ON mydb 修改保留期 ALTER RETENTION POLICY default ON online DEFAULT 删除保留期 DROP RETENTION POLICY &lt;retentionpolicy&gt; ON &lt;database&gt; 创建保留期 REATE RETENTION POLICY &quot;rp_name&quot; ON &quot;db_name&quot; DURATION 30d REPLICATION 1 DEFAULT rp_name：策略名 db_name：具体的数据库名 30d：保存30天，30天之前的数据将被删除 它具有各种时间参数，比如：h（小时），w（星期）m minutes h hours d days w weeks INF infinite REPLICATION 1：副本个数，这里填1就可以了 DEFAULT设为默认的策略","tags":[{"name":"数据库","slug":"数据库","permalink":"http://blog.feelyou.top/tags/数据库/"}]},{"title":"【leetcode】1.两数之和","date":"2018-12-04T01:35:00.000Z","path":"posts/leetcode1.html","text":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的 两个 整数。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] python暴力破解1234567891011class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; for i in range(len(nums)-1): for j in range(i+1, len(nums)): if nums[i] + nums[j] == target: return [i,j]","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://blog.feelyou.top/tags/leetcode/"}]},{"title":"Handle Imbalanced Dataset","date":"2018-11-30T11:07:00.000Z","path":"posts/2490200157.html","text":"For common cases such as ads clickthrough log, the dataset is extremely imbalanced. This can affect the training of xgboost model, and there are two ways to improve it.• If you care only about the ranking order (AUC) of your prediction◦ Balance the positive and negative weights, via scale_pos_weight;◦ Use AUC for evaluation.• If you care about predicting the right probability◦ In such a case, you cannot re-balance the dataset;◦ In such a case, set parameter max_delta_step to a finite number (say 1) will help convergence.","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://blog.feelyou.top/tags/机器学习/"}]},{"title":"文本挖掘初探","date":"2018-11-30T11:00:00.000Z","path":"posts/2653774897.html","text":"获取文本 对文本进行预处理 分词系统 去除停词 特征选择 利用算法进行挖掘（文本分类，文本聚类） 模型评价 文本分类应用 新闻出版社按照栏目分类（政治、军事、娱乐）； 网页分类； 个性化新闻推荐； 垃圾邮件过滤； 文本聚类应用 多文本自动文摘（NLP）； 对搜索引擎的结果聚类； 用户兴趣模式挖掘； 文档集合的自动整理； 关联规则 穿衣搭配推荐 互联网情绪指标和生猪价格的关联共享挖掘和预测 依据用户轨迹的商户精准营销 地点推荐系统 气象分析 事故成因分析","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://blog.feelyou.top/tags/机器学习/"}]},{"title":"关于房产去库存、房产税的分析","date":"2018-11-30T10:55:04.000Z","path":"posts/3042294388.html","text":"情况说明：目前随着中央一系列房地产政策的出台，我国房价出现了相应的变化，具体表现为北上广深等特大城市房价一路猛涨，而二三线城市房价略有小幅下跌，楼市呈现冰火两重天的景象。本文就一线城市代表北京和二三线城市荆州的房地产情况做了如下的比较分析。 政策说明： l 房产去库存： 事件背景：2015年12月20日至21日在北京举行的中央城市工作会议上指出，明年经济社会发展五大任务之一就是化解房地产库存。鼓励房地产开发企业顺应市场规律调整营销策略，适当降低商品住房价格。有分析人士指出，这预示着我国城市工作将迎来重大变化，也将对楼市和房企的命运产生重大影响。 推动路径：一是通过新农民工市民化消化；二是通过房地产企业购并消化；三是通过取消限购来消化,更多城市限贷或限购政策待取消,特大城市二手房限制政策或放宽；四是通过扩大政府购买消化。 成效：国家统计局2016年4月15日公布最近数据显示，3月末，商品房待售面积73516万平方米，比2月末减少415万平方米。根据全国35个城市库存面积的走势看，也呈现了明显的下滑态势，部分城市的库存甚至步入了罕见的低位，去库存周期在3个月左右的水平，远远低于合理值12个月水平。 l 房产税：房产税是以房屋为征税对象，按房屋的计税余值或租金收入为计税依据，向产权所有人征收的一种财产税。 问题提出：北京作为国家政治、文化、经济中心，吸引着全国各地的人们，这里集聚了中国的大量财富，随着中央各项房产政策的实施，北京房价本年度一路上涨，房屋均价从40000上涨至47500，整体上涨幅度为18.7%，部分区域上涨幅度突破100%，而二三线城市荆州房价小幅下跌后平稳波动。与一线城市如火如荼的房价相比，二三线城市房地产市场呈现出下跌趋势。那么房产去库存、房产税对此轮房价波动起到了什么作用呢？ 问题分析：房产去库存主要所瞄准的群体是二三线城市，多表现为房屋供大于求、大量的房地产开发导致人们无法及时吸纳，造成大量资金流动停滞，影响国家经济发展。房产税政策主要针对已持有一套房产的家庭和部分投机倒把、炒房的人群，提高第二套房的首付比率，甚至限购，以到达平稳猛涨城市房价，抑制上涨房价，满足无房人群的刚需。 就目前而言，北上广深等地区房价依旧高歌猛进，房产去库存的目标已超额完成，这些地区房屋供应量已远远低于人们的需求，房产税的实施对抑制北京房价过快上涨可能起到一定程度的帮助。但北上广深优良的教育资源、医疗资源基础建设，吸引着大量“新市民”的涌入，导致人们对这些城市房屋的需求不断增加，这些对房屋刚需的人们往往不受房产税的管控，房产税的调控对刚需人群来说稍显无力。不过，据了解，北京在高房价的同时，也有相当程度的空置率，全面实施房产税可能会让持有多处房产的人们出售房产，提高地区房屋供给量，对稳定房价、消除房地产泡沫起到了一定作用。 而二三线城市由于没有像北上广深一样的就业机会，发展受到局限，特别是在近几年经济形势不太景气的大氛围下，二三线城市人们和农村人民对房屋需求减弱，房地产行业在近几年不断发力，贷款条件放宽、拿地相对较容易，导致二三线城市出现大量房屋库存，严重影响到经济发展，大量的烂尾楼工程出现可能导致地区经济动荡。所以，实行房产去库存政策是大势所趋。在政策的倡导下，二三线城市房价大量下调，调整房屋建筑审批流程，从源头上缩紧库存，激活实体经济发展，营造健康持续的房地产环境。然而，二三线城市人们购买力有限，无法吸收如此之多的房产。所以二三线城市依旧可能持续下跌。 总结：冰火两重天的房产市场，其根本原因是地区发展不平衡，经济发展过于集中，资源分配不均。中央在抑制房价猛涨、打压炒房行为的同时，也要兼顾地区发展平衡，实打实地增加老百姓的钱袋子，增加老百姓的幸福感。在制度方面严格审批拿地建房、商业贷款手续，净化房产制度。这是一场地方与中央一同携手的持久战！","tags":[]},{"title":"Hello World","date":"2018-11-30T10:50:39.000Z","path":"posts/1243066710.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment J_\\alpha(x) = \\sum_{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha}$\\clubsuit$","tags":[]},{"title":"更换国内源","date":"2018-11-30T10:22:00.000Z","path":"posts/548970225.html","text":"conda upgrade打开terminal $HOME/.pip/pip.conf 在home目录下新建文件: .pip/pip.conf若文件不存在，需要首先建立目录： mkdir .pip 然后才能： vim .pip/pip.conf 在这个文件中写入如下内容： [global] index-url = https://pypi.doubanio.com/simple/ timeout = 1000 [install] use-mirrors = true mirrors = https://pypi.doubanio.com// 保存换成速度更快的豆瓣镜像。～～ 替换及重置Homebrew默认源 替换brew.git: cd &quot;$(brew --repo)&quot; git remote set-url origin https://mirrors.ustc.edu.cn/brew.git 替换homebrew-core.git: cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot; git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git &gt; 中国科学技术大学源","tags":[{"name":"python","slug":"python","permalink":"http://blog.feelyou.top/tags/python/"}]},{"title":"A collection of Data Science Interview Questions Solved in Python and Spark   Hands-on Big Data and Machine Learning","date":"2018-11-30T09:59:00.000Z","path":"posts/1984236213.html","text":"1.What are the most important machine learning techniques? 2.Why is it important to have a robust set of metrics for machine learning? 3.Why are Features extraction and engineering so important in machine learning? 5.What is a training set, a validation set, a test set and a gold set in supervised and unsupervised learning? 6.What is a Bias - Variance tradeoff? 7.What is a cross-validation and what is an overfitting? 8.Why are vectors and norms used in machine learning? 9.What are Numpy, Scipy and Spark essential datatypes? 10.Can you provide an example for Map and Reduce in Spark? (Let’s compute the Mean Square Error) 11.Can you provide examples for other computations in Spark? 12.How does Python interact with Spark 13.What is Spark support for Machine Learning? 14.How does Spark work in a parallel environment 15.What is the mean, the variance, and the covariance? 16.What are percentiles and quartiles? 17.Can you transform an XML file into Python Pandas? 18.Can you read HTML into Python Pandas? 19.Can you read JSON into Python Pandas? 20.Can you draw a function from Python? 21.Can you represent a graph in Python? 22.What is an Ipython notebook? 23.What is a convenient tool for performing data statistics? 24.How is it convenient to visualize data statistics 25.How to compute covariance and correlation matrices with pandas 26.Can you provide an example of connection to the Twitter API? 27.Can you provide an example of connection to the LinkedIn API? 28.Can you provide an example of connection to the Facebook API? 29.What is a TFxIDF? 30.What is “features hashing”? And why is it useful for BigData? 31.What is “continuous features binning”? 32.What is an LP normalization? 33.What is a Chi Square Selection? 34.What is mutual information and how can it be used for features selection? 35.What is a loss function, what are linear models, and what do we mean by regularization parameters in machine learning? 36.What is an odd ratio? 37.What is a sigmoid function and what is a logistic function? 38.What is a gradient descent? 39.What is a stochastic gradient descent? 40.What is a Linear Least Square Regression? 41.What are Lasso, Ridge, and ElasticNet regularizations? 42.What is a Logistic Regression? 43.What is a stepwise regression? 44.How to include nonlinear information into linear models 45.What is a Naïve Bayes classifier? 46.What is a Bernoulli and a Multivariate Naïve Bayes? 47.What is a Gaussian? 48.What is a Standard Scaling? 49.Why are statistical distributions important? 50.Can you compare your data with some distribution? What is a qq-plot? 51.What is a Gaussian Naïve Bayes? 52.What is another way to use Naïve Bayes with continuous data? 53.What is the Nearest Neighbor classification? 54.What are Support Vector Machines (SVM)? 55.What are SVM Kernel tricks? 56.What is K-Means Clustering? 57.Can you provide an example for Text Classification with Spark? 58.Where to go from here 59.Ultra-Quick introduction to Python 60.Ultra-Quick introduction to Probabilities 61.Ultra-Quick introduction to Matrices and Vectors 摘录来自: Antonio Gulli. “A collection of Data Science Interview Questions Solved in Python and Spark: BigData and Machine Learning in Python and Spark (A Collection of Programming Interview Questions Book 6)”。 iBooks.","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://blog.feelyou.top/tags/机器学习/"}]},{"title":"1、什么是最重要的机器学习技术？","date":"2018-11-30T09:43:00.000Z","path":"posts/164851981.html","text":"在Alan Turing最著名的文章《Computing Machinery and Intelligence 》所问的一个基本问题“机器能做我们所做（所思考）的吗？”机器学习不是关于“思考”的，但是与一个相关活动有关：学习或者说是完善。就像Arthur Samuel所言，“这种学习给予了计算机不用明确的编程就可以学习的能力！“ 机器学习技术一般地被分为两个类别： 在监督学习部分的栗子中，计算机通过得到的一个输入去“学习”模型，预测出一个合适的、误差最小的输出。分类、神经网络和回归都是监督学习的栗子。对于所有这些技术来说，我们可以假设这里有一个圣人或者老师“教”计算机如何使用课堂学到的东西去处理新的未见过的数据。 无监督学习，计算机则没有老师，他们只能孤独的寻找数据的结构、模式、特点（anomalies）。聚类和密度估计就是无监督学习的典型栗子。 让我们现在回顾一下主要的机器学习技术： 在分类中，“老师”代表的是输入、目标类型部分，计算机学习对新的未测试的数据根据属性分类。朴素贝叶斯、支持向量机、决策树和神经网络都是分类的方法。前两种会在这一卷里讨论，其余的几个则会在下一卷。 在回归中，“老师”代表着输入和连续目标对象，计算机学习如何在新的、未测试的数据中预测连续值。线性回归和逻辑回归会在本卷讨论。决策树、支持向量机、神经网络也可以用于回归。 在关联规则学习中，计算机将面对大量观测值，这些将组成多元化的变量，这个任务是学习各个变量之间的关系，例如A&amp;B—&gt;C（即，如果A和B同时发生，则C也将发生）。 聚类，计算机学习如何把观测值划分到多种子集中，那样每一部分都将通过许多定义明确的矩阵由相同种类的观测值组成K-Means 和DBSCAN 也是这一类算法。 密度估计，计算机学习如何去发现描述型数据的统计值，算法例如EM(Expectation Maximization,最大期望)","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://blog.feelyou.top/tags/机器学习/"}]},{"title":"Spark机器学习","date":"2018-11-27T14:52:00.000Z","path":"posts/614799361.html","text":"spark简介Apache Spark是一个注重对低延迟任务优化的分布式计算框架，完全兼容Hadoop生态系统，同时提供针对Scala、Java、Python语言的原生API，它还自带分布式机器学习和数据挖掘工具包MLib。","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://blog.feelyou.top/tags/机器学习/"},{"name":"spark","slug":"spark","permalink":"http://blog.feelyou.top/tags/spark/"}]},{"title":"用户画像user profile","date":"2018-11-26T06:25:00.000Z","path":"posts/3593045581.html","text":"什么是用户画像（ personas）? Alan Cooper （交互设计之父）最早提出了 persona 的概念:“Personas are a concrete representation of target users.”Persona 是真实用户的虚拟代表,是 建立在一系列真实数据(Marketing data,Usability data)之上的目标用户模型。通过用户调研去了解用户,根据他们的目标、行为和观点的差 异,将他们区分为不同的类型,然后每种类型中抽取出典型特征,赋予名字、照片、一些人口统计学要素、场景等描述,就形成了一个人物原型 (personas)。 用户标签 权重建模 时间（时间戳、时间长度） 地点 网址决定权重，内容决定标签 时间（浏览、点赞、收藏） 对应分析 homework 提取‘tag’ 所在地区 评分 tags 店名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121tm=readLines(&quot;tmall1.txt&quot;)write.table(tm,&quot;分析.txt&quot;)tm11=read.table(&quot;分析.txt&quot;,sep=&quot;|&quot;,encoding=&quot;UTF-8&quot;)tm12=read.table(&quot;分析.txt&quot;,sep=&quot;,&quot;)# == 文本预处理 res=tm11[tm11!=&quot; &quot;] #剔除通用标题 res=gsub(pattern=&quot;presentDay,presentTime,itrm_id,goodsName,shopName,price,price_ave,monthly_sales,comments,miaoshu,fuwu,wuliu,productDescription,seller,info,remarks&quot;,&quot; &quot;,res)#剔除特殊词 res=gsub(pattern=&quot;[我|你|的|了|是]&quot;,&quot; &quot;,res) #清理文本里的回车！否则每个回车就会被识别成一段文本res=gsub(&quot;\\n&quot;,&quot;&quot;,res)################library(rJava) #library(Rwordseg)#install.packages(&quot;Rwordseg&quot;, repos = &quot;http://R-Forge.R-project.org&quot;) library(&quot;jiebaR&quot;)# == 分词+频数统计 wk=worker()words=wk[res]##### 去除所有的数字words=gsub(&quot;\\\\d&quot;,&quot;&quot;,words)word=lapply(X=words, FUN=strsplit, &quot; &quot;) v=table(unlist(word)) # 降序排序 v=rev(sort(v)) d=data.frame(word=names(v), freq=v) #$ 过滤掉1个字和词频小于70的记录 d1=subset(d,nchar(as.character(d$word))&gt;1 &amp; d$freq.Freq&gt;=70) # == 输出结果write.table(d1, file=&quot;keyword.txt&quot;, row.names=FALSE) #############绘制词汇图####################3library(&quot;wordcloud&quot;)mycolors &lt;- brewer.pal(8,&quot;Dark2&quot;)#设置一个颜色d2=d1[,-2]wordcloud(d2[1:30,]$word,d2[1:30,]$freq.Freq,random.order=FALSE,random.color=FALSE,colors=mycolors,family=&quot;myFont3&quot;)write.csv(d2[1:30,], file=&quot;E:\\\\ 30个keyword.csv&quot;, row.names=FALSE) ############ kmeans聚类 #######################res1=res[1:10000]#筛选500个样本做测试words1=wk[res1]word1=lapply(X=words, FUN=strsplit, &quot; &quot;) v1=table(unlist(word1)) # 降序排序 v1=rev(sort(v1)) d11=data.frame(word1=names(v1), freq=v1) # 过滤掉1个字和词频小于100的记录 d12=subset(d11, nchar(as.character(d11$word))&gt;1 &amp; d11$freq.Freq&gt;=100) #获得高频词汇rating=matrix(0,length(res1),dim(d12)[1])#生成评价矩阵colnames(rating)=d12[,1]#给矩阵列命名for(i in 1:length(res1))&#123; words=wk[res1[i]]#对每一条记录分析获得词频 word=lapply(X=words, FUN=strsplit, &quot; &quot;) v=table(unlist(word)) # 降序排序 v=rev(sort(v)) dd=data.frame(word=names(v), freq=v) index=intersect(dd[,1],colnames(rating))#找到每条记录中拥有的高频词汇 if(length(index)==0)next for(j in 1:length(index))&#123; jj=which(dd[,1]==index[j]) rating[i,colnames(rating)==index[j]]=dd[jj,2][[1]]#高频词汇的数量赋值到评价矩阵 &#125; &#125;write.table(rating, file=&quot;评价矩阵.txt&quot;, row.names=FALSE) kmeans(rating,5)#对评价矩阵进行k均值聚类result=read.csv(&quot;E:\\\\ 聚类结果.csv&quot;)colnames(result)=d[1:30,1]###分类别c1=result[result[,31]==1,]c2=result[result[,31]==2,]c3=result[result[,31]==3,]freq1=apply(c1,2,sum)[-31]freq2=apply(c2,2,sum)[-31]freq3=apply(c3,2,sum)[-31]library(&quot;wordcloud&quot;)mycolors &lt;- brewer.pal(8,&quot;Dark2&quot;)#设置一个颜色系：wordcloud(colnames(result)[-17],freq1[-17],random.order=FALSE,random.color=FALSE,colors=mycolors,family=&quot;myFont3&quot;)wordcloud(colnames(result)[-17],freq2[-17],random.order=FALSE,random.color=FALSE,colors=mycolors,family=&quot;myFont3&quot;)wordcloud(colnames(result)[-17],freq3[-17],random.order=FALSE,random.color=FALSE,colors=mycolors,family=&quot;myFont3&quot;)######算法比较y=rbind(matrix(rnorm(10000,mean=2,sd=0.3),ncol=10),matrix(rnorm(10000,mean=1,sd=0.7),ncol=10))#生成两类随机数合并colnames(y)=c(paste(&quot;y&quot;,1:10))#变量名#Kmeans算法聚类cl=kmeans(y,2)pch1=rep(&quot;1&quot;,1000)#类标号pch2=rep(&quot;2&quot;,1000)plot(y,col=cl$cluster,pch=c(rep(&quot;1&quot;,1000),rep(&quot;2&quot;,1000)),main=&quot;kmeans算法聚类图&quot;)#每个类样本points(cl$centers,col=3,pch=&quot;*&quot;,cex=3)#每个类中心","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://blog.feelyou.top/tags/机器学习/"}]}]